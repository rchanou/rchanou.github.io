<head>
  <!--script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/kefir/3.3.0/kefir.min.js"></script-->
  <script src="https://cdn.socket.io/socket.io-1.4.5.js"></script>
  <script src="https://code.jquery.com/jquery-3.1.0.min.js"
    integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s="
    crossorigin="anonymous"
  ></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.12.0/babel.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/seamless-immutable/6.1.1/seamless-immutable.development.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/react/15.3.0/react.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/react/15.3.0/react-dom.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      color: hsl(0,0%,95%);
      font-family: sans-serif;
    }

    label {
      min-width: 10em;
    }

    input, button {
      color: black;
      width: 3em;
    }

    body {
      background: hsl(0,0%,9%);
      overflow: hidden;
      display: flex;
      justify-content: center;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <div>
    Loading...
  </div>
  <script type='text/javascript'>
    var devUrl;
  </script>
  <script type='text/javascript' src='dev-setup.js'></script>
  <script type='text/babel'>
    function getColorFromId(id){
      var hue = 0;
      for (var i in id){
        hue += Math.pow(id.charCodeAt(i), 2);
      }
      return 'hsl(' + (hue % 360) + ',50%,73%)';
    }

    const absoluteStyle = {
      position: 'absolute',
      top: 0,
      left: 0
    };

    const getViewCoord = (coord, opts) =>
      (coord * opts.mult - opts.minBound)
      / (opts.maxBound - opts.minBound);
      //* atom.winHeight;

    class TrackMap extends React.Component {
      state = {
        atom: Immutable({
          winWidth: 100,
          winHeight: 100,
          xOpts: {
            minBound: -39,
            maxBound: 39,
            mult: 1
          },
          yOpts: {
            minBound: -50,
            maxBound: 30,
            mult: -1
          },
          /*xOpts.minBound: 0,
          xOpts.maxBound: 55,
          yOpts.minBound: -65,
          yOpts.maxBound: 5,*/
          tags: {},
          smooth: true,
          showAllDots: false,
          lines: [{
            x1: 0, y1: 0, x2: 0, y2: 0, id: 'mouse'
          }]
        })
      }

      render(){
        const { atom } = this.state;

        const mapStyle = {
          ...absoluteStyle,
          width: atom.winHeight,
          height: atom.winHeight
        }

        return <div
          style={{
            position: 'relative',
            width: atom.winHeight,
            height: atom.winHeight
          }}
        >
          <canvas ref='canvas'
            width={atom.winHeight} height={atom.winHeight}
            style={mapStyle}
          />

          <svg style={mapStyle} width={atom.winHeight} height={atom.winHeight}>
            {atom.lines.map(
              (line, i) => <line key={i}
                stroke={getColorFromId(line.id)} strokeWidth={3}
                x1={getViewCoord(line.x1, atom.xOpts) * atom.winHeight}
                y1={getViewCoord(line.y1, atom.yOpts) * atom.winHeight}
                x2={getViewCoord(line.x2, atom.xOpts) * atom.winHeight}
                y2={getViewCoord(line.y2, atom.yOpts) * atom.winHeight}
              />
            )}
          </svg>

          {Object.entries(atom.tags)
          //.filter( (t, i) => i < 3 )
          .map(
            ([tagId, tag]) => (atom.showAllDots || tag.inRaceCount > 5)
            && <div key={tagId}
              style={{
                ...absoluteStyle,
                width: 14, height: 14, borderRadius: 7,
                background: getColorFromId(tagId),
                transformOrigin: '7px 7px',
                transition: atom.smooth && 'all 0.3s',
                transform: `translate(${
                  getViewCoord(tag.points[0].x, atom.xOpts) * atom.winHeight
                }px,${
                  getViewCoord(tag.points[0].y, atom.yOpts) * atom.winHeight
                }px)`
              }}
            />
          )}

          <form
            style={{
              position: 'fixed',
              top: 0, left: 0,
              width: '100%', height: '100%',
              display: 'flex', flexDirection: 'column'
            }}
          >
            <div>
              {atom.lines[0].x1.toFixed(3)},{atom.lines[0].y1.toFixed(3)} to
              {atom.lines[0].x2.toFixed(3)},{atom.lines[0].y2.toFixed(3)}
            </div>
            <div>
              <label>Smooth</label>
              <input type='checkbox' checked={atom.smooth}
                onChange={
                  e => this.setState({ atom: atom.set('smooth', e.target.checked) })
                }
              />
            </div>
            <div>
              <label>All Dots</label>
              <input type='checkbox' checked={atom.showAllDots}
                onChange={
                  e => this.setState({ atom: atom.set('showAllDots', e.target.checked) })
                }
              />
            </div>
            <div>
              <label>Flip X</label>
              <input type='checkbox' checked={atom.xOpts.mult === -1}
                onChange={
                  e => this.setState({ atom: atom.setIn(['xOpts', 'mult'], e.target.checked? -1: 1) })
                }
              />
            </div>
            <div>
              <label>Flip Y</label>
              <input type='checkbox' checked={atom.yOpts.mult === -1}
                onChange={
                  e => this.setState({ atom: atom.setIn(['yOpts', 'mult'], e.target.checked? -1: 1) })
                }
              />
            </div>
            <div>
              <label>Min X</label>
              <input type='number' value={atom.xOpts.minBound * atom.xOpts.mult}
                onChange={
                  e => this.setState({
                    atom: atom.setIn(
                      ['xOpts', 'minBound'], e.target.value * atom.xOpts.mult
                    )
                  })
                }
              />
            </div>
            <div>
              <label>Max X</label>
              <input type='number' value={atom.xOpts.maxBound * atom.xOpts.mult}
                onChange={
                  e => this.setState({
                    atom: atom.setIn(
                      ['xOpts', 'maxBound'], e.target.value * atom.xOpts.mult
                    )
                  })
                }
              />
            </div>
            <div>
              <label>Min Y</label>
              <input type='number' value={atom.yOpts.minBound * atom.yOpts.mult}
                onChange={
                  e => this.setState({
                    atom: atom.setIn(
                      ['yOpts', 'minBound'], e.target.value * atom.yOpts.mult
                    )
                  })
                }
              />
            </div>
            <div>
              <label>Max Y</label>
              <input type='number' value={atom.yOpts.maxBound * atom.yOpts.mult}
                onChange={
                  e => this.setState({
                    atom: atom.setIn(
                      ['yOpts', 'maxBound'], e.target.value * atom.yOpts.mult
                    )
                  })
                }
              />
            </div>
          </form>
        </div>;
      }

      componentDidMount(){
        const canvasEl = ReactDOM.findDOMNode(this.refs.canvas);
        const context = canvasEl.getContext('2d');
        context.globalAlpha = 0.2;
        context.fillStyle = 'grey';

        const socket = io(devUrl);

        socket.on('point', data => { //console.log('point', atom);
          const { atom } = this.state;

          if (!atom.tags[data.id]){
            context.globalAlpha = 0.2;
            context.fillStyle = 'grey';

            const newTag = {
              points: [{
                x: data.x,
                y: data.y
              }],
              angle: 0,
              avgStep: 0,
              pointCount: 0,
              activeCount: 0,
              firstTime: data.t,
              inRaceCount: 0
            };

            this.setState({
              atom: this.state.atom.setIn(
                ['tags', data.id],
                newTag
              )
            });
          } else {
            const thisTag = atom.tags[data.id];

            if (true || thisTag.points.length >= 1){
              const prevPoint = thisTag.points[0];
              //const nextPoint = thisTag.points[1];


              const squareStep = Math.pow(data.x - prevPoint.x, 2)
                + Math.pow(data.y - prevPoint.y, 2);

              if (false && squareStep > 36){
                //console.log('throw', squareStep, data.x, data.y, prevPoint.x, prevPoint.y);
              } else {
                this.setState({
                  atom: this.state.atom.updateIn(
                    ['tags', data.id],
                    tag => tag.set('points', [{ x: data.x, y: data.y }])
                      .update(
                        'inRaceCount',
                        count => data.loc === 'pit'? 0: (count + 1)
                      )
                  )
                });
              }
            }
          }

          const finalX = getViewCoord(data.x, atom.xOpts) * atom.winHeight;

          const finalY = getViewCoord(data.y, atom.yOpts) * atom.winHeight;

          //console.log(finalX, finalY);

          context.beginPath();
          context.arc(
            finalX, finalY,
            5, 0, 2 * Math.PI, false
          );
          context.fill();
        });


        socket.on('passing', data => {
        });

        socket.on('config', shapes => {
          //console.log(data);
          let newAtom = this.state.atom;

          for (const item of shapes){
            if (item.id === 'view'){
              const minX = Math.min(
                item.coordinates[0].x, item.coordinates[1].x
              );
              const maxX = Math.max(
                item.coordinates[0].x, item.coordinates[1].x
              );
              const minY = Math.min(
                item.coordinates[0].y, item.coordinates[1].y
              );
              const maxY = Math.max(
                item.coordinates[0].y, item.coordinates[1].y
              );

              newAtom = newAtom.setIn(['xOpts', 'minBound'], minX)
                .setIn(['xOpts', 'maxBound'], maxX)
                .setIn(['yOpts', 'minBound'], minY)
                .setIn(['yOpts', 'maxBound'], maxY)
            } else if (item.type === 'line'){
              newAtom = newAtom.update(
                'lines',
                lines => lines.concat({
                  x1: item.coordinates[0].x,
                  y1: item.coordinates[0].y,
                  x2: item.coordinates[1].x,
                  y2: item.coordinates[1].y,
                  id: item.id
                  //color: getColorFromId(item.id)
                })
              )
            } else if (item.type === 'polygon'){
              newAtom = newAtom.update(
                'lines',
                lines => lines.concat(
                  item.coordinates.map(
                    ([x,y], i) => ({
                      x1: x,
                      y1: y,
                      ...i === (item.coordinates.length - 1)? {
                        x2: item.coordinates[0][0],
                        y2: item.coordinates[0][1]
                      }: {
                        x2: item.coordinates[i + 1][0],
                        y2: item.coordinates[i + 1][1]
                      },
                      id: item.id
                      //color: getColorFromId(item.id)
                    })
                  )
                )
              );
            }
          }

          this.setState({
            atom: newAtom
          });
        });
        socket.emit('config');

        const $win = $(window);
        $win.resize(o=> {
          this.setState({
            atom: this.state.atom.set('winWidth', $win.width()).set('winHeight', $win.height())
          }, o=>{
            context.clearRect(0, 0, canvasEl.width, canvasEl.height);
            context.globalAlpha = 0.2;
            context.fillStyle = 'grey';
          });
        })
        .resize();

        $win.click( e => {
          const { atom } = this.state;
          const offset = $(canvasEl).offset();
          const viewX = e.pageX - offset.left;
          const viewY = e.pageY - offset.top;

          const xRatio = viewX / atom.winHeight;
          const yRatio = viewY / atom.winHeight;

          const calcedXSize = atom.xOpts.maxBound - atom.xOpts.minBound;
          const calcedYSize = atom.yOpts.maxBound - atom.yOpts.minBound;

          const finalX = ((xRatio * calcedXSize) + atom.xOpts.minBound) / atom.xOpts.mult;
          const finalY = ((yRatio  * calcedYSize) + atom.yOpts.minBound) / atom.yOpts.mult;

          this.setState({
            atom: atom.setIn(['lines', 0, 'x1'], finalX).setIn(['lines', 0, 'y1'], finalY)
          });

          console.log('x', finalX, 'y', finalY);
        });

        let mouseFree = true;
        $win.mousemove( e => {
          if (!mouseFree){
            return;
          }
          mouseFree = false;
          requestAnimationFrame(
            o=> setTimeout(
              o=> { mouseFree = true; }, 111
            )
          );


          const { atom } = this.state;
          const offset = $(canvasEl).offset();
          const viewX = e.pageX - offset.left;
          const viewY = e.pageY - offset.top;

          const xRatio = viewX / atom.winHeight;
          const yRatio = viewY / atom.winHeight;

          const calcedXSize = atom.xOpts.maxBound - atom.xOpts.minBound;
          const calcedYSize = atom.yOpts.maxBound - atom.yOpts.minBound;

          const finalX = ((xRatio * calcedXSize) + atom.xOpts.minBound) / atom.xOpts.mult;
          const finalY = ((yRatio  * calcedYSize) + atom.yOpts.minBound) / atom.yOpts.mult;

          this.setState({
            atom: atom.setIn(['lines', 0, 'x2'], finalX).setIn(['lines', 0, 'y2'], finalY)
          });
        });

        window.me = this;
      }

      componentDidUpdate(){
        //console.log(this.state.atom.xOpts.maxBound);
      }
    }


    ReactDOM.render(
      <TrackMap />, document.body.firstElementChild
    );
  </script>
</body>
