<?php
/**
 * Club Speed API
 *
 * Proposed API for accessing racer, heat and scoring information
 * generated by Club Speed server.
 * @author Wes Ratcliff <wes@clubspeed.com>
 * @version 0.1
 */

/**
 * /races/next
 * /races/fastest
 */
class Races
{
    public $restler;
    private $webapi;

    function __construct(){
        // header('Access-Control-Allow-Origin: *'); //Here for all /say
        $this->webapi = @$GLOBALS['webapi'];
    }

    public function index($race_id, $sub = null) {
        //if(!is_numeric($race_id) || $race_id !== 'current') throw new RestException(412,'Not a valid race id');
        if($race_id == 'current_race_id') return $this->current();
        if($race_id == 'current') $race_id = $this->current();
        if($race_id == 'fastest') return $this->fastest();
        if($race_id == 'next') return $this->next(@$_GET['track_id'], @$_GET['offset']);
        if($race_id == 'previous') return $this->previous(@$_GET['track_id'], @$_GET['offset']);
        if($race_id == 'total_laps') return $this->total_laps();
        if($race_id == 'lap_number') return $this->lap_number($sub);
        if($race_id == 'scoreboard') return $this->scoreboard(@$_GET['track_id'], @$_GET['heat_id']);
        if($race_id == 'copy') return $this->copy(@$_GET['from'], @$_GET['to'], @$_GET['track_id']);
        if($race_id == 'races') return $this->races(@$_GET['track_id']);
        if($race_id == 'since') return $this->since();
        if($race_id == 'final_positions') return $this->final_positions();
        if($race_id == 'matching') return $this->matching();
        if($race_id == 'upcoming_heat_types') return $this->upcoming_heat_types(@$_GET['date']);
        if($race_id == 'upcoming') return $this->upcoming();
        if($race_id == 'start') return $this->start(@$_REQUEST['heatId']);
        if($race_id == 'stop') return $this->stop(@$_REQUEST['trackId']);

        if($sub != null) {
            switch($sub) {
                case 'current':
                    return $race_id;
                    break;
                case 'laps':
                    $_GET['lap_id'] = isset($_GET['lap_id']) ? $_GET['lap_id']: 0;
                    $_GET['racer_id'] = isset($_GET['racer_id']) ? $_GET['racer_id']: null;
                    return $this->laps($race_id, $_GET['lap_id'], $_GET['racer_id']);
                    break;
                case 'number_of_laps':
                    return $this->number_of_laps($race_id);
                    break;
            }
        } else {
            return $this->race($race_id);
        }
    }

    public function start($heatId) {
        try {
            $this->webapi->startRace($heatId);
        }
        catch (\Exception $e) {
            throw new \RestException($e->getCode(), $e->getMessage());
        }
    }

    public function stop($trackId) {
        try {
            $this->webapi->stopRace($trackId);
        }
        catch (\Exception $e) {
            throw new \RestException($e->getCode(), $e->getMessage());
        }
    }

    public function copy($fromDate = null, $toDate = null, $track_id = null, $options = null) {
        if (!\ClubSpeed\Security\Authenticate::privateAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }
        // TODO Options? (only web or only A&D)
        // TODO Accept heat numbers to copy just those?
        
        // Setup incoming variables
        if(empty($fromDate)) throw new RestException(412, 'A valid "from" date was not given.');
        if(empty($toDate))   throw new RestException(412, 'A valid "to" date was not given.');
        if(empty($track_id)) throw new RestException(412, 'A valid "track id" was not given.');
        
        // Get "from" races
        $tsql = "SELECT TrackNo, HeatTypeNo, LapsOrMinutes, WinBy, RaceBy, ScheduleDuration, PointsNeeded, SpeedLevel, HeatColor, MemberOnly, ScoreID, RacersPerHeat, CadetsPerHeat, ScheduledTime FROM HeatMain WHERE EventRound IS NULL AND ScheduledTime BETWEEN ? AND ? AND TrackNo = ?";
        $fromStartOfDay = date($GLOBALS['dateFormat'] . " 00:00:00", strtotime($fromDate));
        $fromEndOfDay   = date($GLOBALS['dateFormat'] . " 23:59:59", strtotime($fromDate));
        $tsql_params = array($fromStartOfDay, $fromEndOfDay, $track_id);
        $templateRaces = $this->run_query($tsql, $tsql_params);
        
        // Build and insert each new race
        foreach($templateRaces as $templateRace) {
            // Modify template into "new" race to insert
            $race = $templateRace;
            $race['ScheduledTime'] = $toDate . substr($race['ScheduledTime'], -13);
            $race['HeatStatus'] = 0;
            $race['Begining'] = null;
            $race['Finish'] = null;
            $race['NumberOfReservation'] = 0;
            $race['NumberOfCadetReservation'] = 0;
            
            // Insert race
            $fields = $placeholders = $params = array();
            foreach($race as $field => $data) {
                $fields[] = $field;
                $placeholders[] = '?';
                $params[] = $data;
            }
            $tsql = "INSERT INTO HeatMain ( " . implode(',', $fields) . " ) OUTPUT INSERTED.HeatNo VALUES ( " . implode(',', $placeholders) . " )";
            $result = $this->run_query($tsql, $params);
        }
        
        // TODO Let MainEngine know to refresh the schedule
        
        return array('result' => 'success');
            
    }

    public function total_laps() {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }
        $tsql = "SELECT COUNT(*) AS total_laps FROM RacingData";
        $tsql_params = array();

        $rows = $this->run_query($tsql, $tsql_params);

        $output = array();

        if(count($rows)) {
            return $rows;
        } else {
            $_GET['suppress_response_codes'] = true;
            throw new RestException(412, 'No results returned.');
        }
    }

    public function lap_number($num) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }
        if(empty($num) || !is_numeric($num)) {
            $_GET['suppress_response_codes'] = true;
            throw new RestException(412, 'No lap number given.');
        }
        $tsql = "WITH Records AS (SELECT row_number() OVER (ORDER BY ID) AS 'row', rd.*, c.FName, c.LName FROM RacingData rd LEFT JOIN Customers c ON rd.CustID = c.CustID) SELECT * FROM records WHERE row = ?";
        $tsql_params = array(&$num);

        $row = $this->run_query($tsql, $tsql_params);

        $output = array();

        if(count($row)) {
            //return $row;
            return array('lap_number' => $row[0]['row'],
                'lap_id'     => $row[0]['ID'],
                'first_name' => $row[0]['FName'],
                'last_name'  => $row[0]['LName'],
                'racer_id'   => $row[0]['CustID'],
                'lap_time'   => round($row[0]['LTime'] / 1000, 3),
                'race_id'    => $row[0]['HeatNo']);
        } else {
            $_GET['suppress_response_codes'] = true;
            throw new RestException(412, 'No results returned.');
        }
    }

    /**
     * This function returns the next upcoming heat's id, or error code 412 if
     * no races are coming up. Note that if a track is running behind, this method will not return
     * the next heat if the time for it to have started has already passed. This is a limitation of
     * the stored procedure being used.
     *
     * @param null $track The track to pull data from. Currently being unused.
     * @param int $nextNum See Wes. Currently being unused.
     * @return mixed The 'id' field of the next heat coming up.
     * @throws RestException Error code 412 is returned if no races are coming up.
     */
    public function upcoming($track = null) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }
        $track_id = (isset($_GET['track']) && is_numeric($_GET['track'])) ? (int)$_GET['track'] : 1; // Default to Track 1
        $return = array('races' => array());

        // TODO Filter by Speed Level

        $tsql = 'SELECT * FROM HeatMain WHERE TrackNo = ? AND HeatStatus IN (0,4) AND ScheduledTime > (SELECT TOP(1) hm.ScheduledTime AS starts_at FROM HeatMain hm WHERE hm.TrackNo = ? AND hm.HeatStatus IN (1,2,3) ORDER BY hm.Begining DESC) ORDER BY ScheduledTime ASC';
        $tsql_params = array(&$track_id, &$track_id);
        $upcomingRaces = $this->run_query($tsql, $tsql_params);
        
        forEach($upcomingRaces as $id => $race) {
            $populatedRace = $this->race($race['HeatNo']);
            $populatedRace['race']['total_spots'] = $race['RacersPerHeat'];
            $return['races'][] = $populatedRace;
        }
        return $return;
    }
        
    public function next($track = null, $offset = 0) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        $track_id = (isset($_GET['track']) && is_numeric($_GET['track'])) ? (int)$_GET['track'] : 1; // Default to Track 1
        $offset = (int)$offset + 1; // Modify to match SQL Server where 1 = First Row

        // TODO Filter by Speed Level


        $tsql = <<<EOS
WITH LAST_RACE_CTE AS (
    SELECT TOP 1
        hm.ScheduledTime
    FROM dbo.HeatMain hm
    WHERE
        hm.TrackNo = ?
        AND hm.HeatStatus IN (1,2,3)
    ORDER BY
        hm.Begining DESC
)
, NEXT_RACES_CTE AS (
    SELECT
        hm.*
        , ROW_NUMBER() OVER (ORDER BY hm.ScheduledTime) AS Rank
    FROM dbo.HeatMain hm
    OUTER APPLY LAST_RACE_CTE lrc
    WHERE
            hm.TrackNo = ?
        AND hm.HeatStatus IN (0,4)
        AND hm.ScheduledTime > lrc.ScheduledTime
        AND hm.ScheduledTime > DATEADD(HOUR, -2, GETDATE())
)
SELECT c.*
FROM NEXT_RACES_CTE c
WHERE
    c.Rank = ?
EOS;
        // $tsql = 'WITH CTE AS (SELECT *, ROW_NUMBER() OVER (ORDER BY ScheduledTime) AS Rank FROM HeatMain WHERE TrackNo = ? AND HeatStatus IN (0,4) AND ScheduledTime > (SELECT TOP(1) hm.ScheduledTime AS starts_at FROM HeatMain hm WHERE hm.TrackNo = ? AND hm.HeatStatus IN (1,2,3) ORDER BY hm.Begining DESC)) SELECT c.* FROM CTE c WHERE Rank = ?';
        $tsql_params = array(&$track_id, &$track_id, &$offset);
        $rows = $this->run_query($tsql, $tsql_params);
        
        if(empty($rows[0]['HeatNo'])) {
            throw new RestException(412, 'No upcoming race found.');
        } 
        else {
            $nextHeatId = $rows[0]['HeatNo'];
        }

        return $this->race($nextHeatId);
    }
        
    public function previous($track = null, $offset = 0) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        $track_id = (isset($_GET['track']) && is_numeric($_GET['track'])) ? (int)$_GET['track'] : 1; // Default to Track 1
        $offset = (int)$offset + 1; // Modify to match SQL Server where 1 = First Row

        // TODO Filter by Speed Level

        $tsql = 'WITH CTE AS (SELECT *, ROW_NUMBER() OVER (ORDER BY Begining DESC) AS Rank FROM HeatMain WHERE TrackNo = ? AND HeatStatus IN (2,3) AND Begining <= (SELECT TOP(1) hm.Begining AS started_at FROM HeatMain hm WHERE hm.TrackNo = ? AND hm.HeatStatus IN (2) ORDER BY hm.Begining DESC ) ) SELECT c.* FROM CTE c WHERE Rank = ?';
        $tsql_params = array(&$track_id, &$track_id, &$offset);
        $rows = $this->run_query($tsql, $tsql_params);
        
        if(empty($rows[0]['HeatNo'])) {
            throw new RestException(412, 'No previous race found.');
        } 
        else {
            $heatId = $rows[0]['HeatNo'];
        }

        return $this->race($heatId);
    }

    public function current($track = null) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        $track_id = (isset($_GET['track_id']) && is_numeric($_GET['track_id'])) ? (int)$_GET['track_id'] : 1;
        $tsql = "SELECT HeatNo FROM HeatMain WHERE (HeatStatus = 1) AND (TrackNo = ?)";
        $tsql_params = array(&$track_id);

        $rows = $this->run_query($tsql, $tsql_params);

        $output = array();

        if(count($rows)) {
            return $rows[0]['HeatNo'];
        } else {
            $_GET['suppress_response_codes'] = true;
            throw new RestException(412, 'Race not currently running');
        }
    }

    public function upcoming_heat_types($date = null) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        //TODO, implement date range to return heat types. For now just return all.
        //$date = date($GLOBALS['dateFormat'] . " 23:59:59", $date);
        
        $tsql = "SELECT HeatTypeNo AS heat_type_id, HeatTypeName AS name FROM HeatTypes WHERE Enabled = 1 AND Deleted = 0 AND Web = 1 ORDER BY HeatTypeName";
        $tsql_params = array();
        $heatTypes = $this->run_query($tsql, $tsql_params);
            
        return array('heatTypes' => $heatTypes);
    }

    public function matching() {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        $tsql_heatType = $tsql_numParticipants = $tsql_numSpots = '';

        // TODO -- pull from configuration
        $blackoutTime = 1*60;  // In minutes
        $maximumDaysOut = 365; // In days
                
        // TODO -- convert start/end into milliseconds then do the conversion back to local time after we've processed it to avoid all the strtotime()'s

        // If no start date given, default to today
        if(!isset($_GET['start'])) {
            $start = date($GLOBALS['dateFormat'] . " H:i:s");
            $end   = date($GLOBALS['dateFormat'] . " H:i:s", strtotime(date($GLOBALS['dateFormat'], strtotime($_GET['start']))) + 24*60*60); // End of today
        }

        // Otherwise, use range given (defaulting to end of day if no end is given)
        else {
            $start = date($GLOBALS['dateFormat'] . " H:i:s", strtotime($_GET['start']));
            $end = isset($_GET['end']) ? date($GLOBALS['dateFormat'] . " H:i:s", strtotime($_GET['end'])) : date("{$GLOBALS['dateFormat']}  H:i:s", strtotime($_GET['start']) + 24*60*60); // Use end, or make it the end of the start day given
        }

        // Change start to enforce the blackout time
        /*$cannotScheduleBefore = time() + $blackoutTime*60;
        if(strtotime($_GET['start']) < $cannotScheduleBefore) {
            $start = date("Y-m-d H:i:s", $cannotScheduleBefore);
        }*/

        // Check to ensure we are not scheduling in the past
        /*if(strtotime($_GET['end']) < time()) {
            throw new RestException(412,'Cannot schedule events in the past');
        }*/

        // Check to ensure we are not scheduling too far ahead
        $maximumSecondsOut = time() + $maximumDaysOut*24*60*60;
        if(strtotime($end) > $maximumSecondsOut || strtotime($_GET['start']) > $maximumSecondsOut) {
            throw new RestException(412,'Cannot schedule more than ' . $maximumDaysOut . ' in advance');
        }

        /**
         * Create optional filters on query
         */
        $tsql_params = array(&$start, &$end);

        // TODO -- allow multiple heat types (or all) to be given
        if(isset($_GET['heatType']) && is_numeric($_GET['heatType'])) {
            $tsql_heatType = 'AND hm.HeatTypeNo = ?';
            $tsql_params[] = &$_GET['heatType'];
        }
                
        // TODO -- filter number of participants
        if(false && isset($_GET['numParticipants']) && is_numeric($_GET['numParticipants'])) {
            $tsql_numParticipants = 'AND SpotsAvailable >= ?';
            $tsql_params[] = &$_GET['numParticipants'];
        }
        else {
            $_GET['numParticipants'] = 1; // Until we filter by "SpotsAvailable" in SQL...
        }

        // TODO -- Add restiction that heat needs to be "closed" or "not run": hm.HeatStatus IN (0, 4)

        $tsql = "SELECT hm.HeatNo, ht.HeatTypeName AS title, hm.HeatNotes AS note, hm.HeatStatus, hm.ScheduledTime AS starts, hm.HeatTypeNo, hm.LapsOrMinutes, hm.RacersPerHeat, hm.TrackNo, hm.WinBy, hm.RaceBy, hm.ScheduleDuration, hm.SpeedLevel, (hm.RacersPerHeat - (hm.NumberOfReservation + hm.NumberOfCadetReservation + COUNT(hd.HeatNo))) AS SpotsAvailable, COUNT(hd.HeatNo) AS NumberOfPaid, hm.NumberOfReservation, hm.NumberOfCadetReservation FROM HeatMain AS hm LEFT OUTER JOIN HeatDetails AS hd ON hm.HeatNo = hd.HeatNo LEFT OUTER JOIN HeatTypes AS ht ON hm.HeatTypeNo = ht.HeatTypeNo WHERE hm.EventRound IS NULL AND (hm.ScheduledTime BETWEEN ? AND ?) {$tsql_heatType} {$tsql_numSpots} {$tsql_numParticipants} GROUP BY hm.HeatNo, ht.HeatTypeName, hm.HeatNotes, hm.HeatStatus, hm.ScheduledTime, hm.HeatTypeNo, hm.LapsOrMinutes, hm.RacersPerHeat, hm.TrackNo, hm.WinBy, hm.RaceBy, hm.ScheduleDuration, hm.SpeedLevel, hm.NumberOfReservation, hm.NumberOfCadetReservation ORDER BY hm.ScheduledTime"; // TODO: Modify to using a subquery so that we can filter on SpotsAvailable

        $scheduledHeats = $this->run_query($tsql, $tsql_params);
                
        $matchingHeats = $scheduledHeats; // To bypass commented out code below

        $matches = array();
        foreach($matchingHeats as $heat) {
             // Until we filter by "SpotsAvailable" in SQL...
            if(isset($_GET['numParticipants']) && is_numeric($_GET['numParticipants']) && (int)$heat['SpotsAvailable'] >= $_GET['numParticipants']) {
                $matches[] = array(
                    'heatId' => (int)$heat['HeatNo'],
                    'trackId' => (int)$heat['TrackNo'],
                    'name' => $heat['title'],
                    'starts' => date("{$GLOBALS['dateFormat']} H:i:s", strtotime($heat['starts'])),
                    'ends' => date("{$GLOBALS['dateFormat']} H:i:s", strtotime($heat['starts']) + (int)$heat['ScheduleDuration']*60),
                    'total_spots' => (int)$heat['RacersPerHeat'],
                    'available_spots' => (int)$heat['SpotsAvailable'],
                    'title'  => $heat['title'],
                    'note'   => $heat['note'],
                    'price'  => 20.00,
                    //'original' => $heat
                );
            }
        }

        return array('races' => $matches);
    }

    public function sort_heatStart($a, $b) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        $adist = intval($a['starts']);
        $bdist = intval($b['starts']);

        if ($adist == $bdist) {
            return 0;
        }
        return ($adist < $bdist) ? -1 : 1;
    }

    public function findMatchingHeats($heats, $numDrivers, $numHeats, $gapInMinutes) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        //usort($heats, array("Races", "sort_heatStart"));

        $availableHeats = array();

        // Once we have the slots, loop through them and see if the pattern we needs can be fulfilled for each one
        foreach($heats as $heat) {

            $potentialHeats = array(); // Heats that match what we're looking for
            // Check to see if the heat in question has enough slots for our drivers (if so, we can proceed further)
            $spotsAvailable = $heat['spots'] - $heat['racers'];

            if($spotsAvailable >= $numDrivers) {
                $potentialHeats[] = $heat; // Put in the first heat;

                // For multiple heat events, add heats that match the criteria to an array
                for($i = 1; $i < $numHeats; $i++) {

                    // Get the heat before this one so we can calculate the next heat needed in the sequence
                    $previousHeat = $potentialHeats[count($potentialHeats) - 1];

                    $nextHeatTime  = $previousHeat['ends'] + ($gapInMinutes * 60);
                    $potentialHeat = $this->findHeat($nextHeatTime, $heats);

                    // If heat is not available or exists but doesn't have spots, abort
                    if(empty($potentialHeat) || $numDrivers > ($potentialHeat['spots'] - $potentialHeat['racers'])) {
                        break;
                    }

                    $potentialHeats[] = $potentialHeat;

                }
            };

            // We have the correct amount of heats that match the criteria, so add them to the available heats
            if(count($potentialHeats) == $numHeats)
                $availableHeats[] = $potentialHeats;
        }

        return $availableHeats;
    }


    public function findHeat($starts, $heats) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        // Loop heats -- if we find a match, return it, otherwise return null
        foreach($heats as $heat) {
            if($heat['starts'] == $starts)
                return $heat;
        }
    }

    public function getHeatSlotsForDay($scheduledHeats, $date, $bookingsStartAt, $bookingsEndAt, $bookingLengthInMinutes = 10, $defaultSpots = 25, $trackId = 0, $daysInAdvance = 365, $blackoutTimeInMinutes = 0) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        $allHeats = array();
        $addedHeats = array();

        $numHeats = floor((strtotime($bookingsEndAt) - strtotime($bookingsStartAt)) / ($bookingLengthInMinutes * 60));

        for($i = 0; $i < $numHeats; $i++) {

            // Create virtual heat
            $virtualHeatTime = strtotime($bookingsStartAt) + ($i * $bookingLengthInMinutes * 60);
            $virtualHeat = array(
                'starts' => $virtualHeatTime,
                'ends' => $virtualHeatTime + ($bookingLengthInMinutes * 60),
                'spots' => $defaultSpots,
                'racers' => 0,
                'title' => 'Virtual',
                'note' => 'Virtual note'
            );

            $doNotAdd = false;

            // Loop through scheduled heats -- if an overlap exists, do not add the virtual
            foreach($scheduledHeats as $key => $scheduled) {


                // Convert scheduled starting and ending into seconds
                $scheduled['starts'] = strtotime($scheduled['starts']);
                $scheduled['ends']   = $scheduled['starts'] + ($scheduled['ScheduleDuration'] * 60);
                $status = isset($scheduled['HeatStatus']) ? $scheduled['HeatStatus'] : null;

                $identifier = !isset($scheduled['HeatNo']) ? $scheduled['EventID'] : $scheduled['HeatNo'];
                if(!in_array($identifier, $addedHeats)) {
                    if($scheduled['ends'] <= strtotime($bookingsStartAt)) { // If the scheduled heat ends before the booking time starts, add it to the array
                        $addedHeats[] = $identifier;
                        $allHeats[] = array(
                            //'heatId' => $scheduled['HeatNo'],
                            'starts' => $scheduled['starts'],
                            'status' => $status,
                            'ends'   => $scheduled['ends'],
                            'spots'  => $scheduled['RacersPerHeat'],
                            'racers' => $scheduled['RacersPerHeat'] - $scheduled['SpotsAvailable'],
                            'title'  => $scheduled['title'],
                            'note'   => $scheduled['note']
                        );
                    } elseif($scheduled['starts'] >= strtotime($bookingsEndAt)) { // If the scheduled heat starts after the booking time ends, add it to the array
                        $addedHeats[] = $identifier;
                        $allHeats[] = array(
                            //'heatId' => $scheduled['HeatNo'],
                            'starts' => $scheduled['starts'],
                            'status' => $status,
                            'ends'   => $scheduled['ends'],
                            'spots'  => $scheduled['RacersPerHeat'],
                            'racers' => $scheduled['RacersPerHeat'] - $scheduled['SpotsAvailable'],
                            'title'  => $scheduled['title'],
                            'note'   => $scheduled['note']
                        );
                    }
                }

                // Check if virtual heat overlaps
                /*if($virtualHeat['starts'] == $scheduled['starts'] && $virtualHeat['ends'] == $scheduled['ends'] // Start and end at same time
                        || (($virtualHeat['starts'] > $scheduled['starts']) && $virtualHeat['starts'] < $scheduled['ends']) // Virtual starts in the middle of existing heat
                        || (($virtualHeat['ends']   > $scheduled['starts']) && $virtualHeat['ends']   < $scheduled['ends']) // Virtual ends in middle of existing heat
                        ) {*/
                if(
                    ($virtualHeat['starts'] >= $scheduled['starts'] && $virtualHeat['ends'] <= $scheduled['ends']) || // Virtual start >= Scheduled Start && Virtual end <= Scheduled End **Virtual within scheduled or same duration
                    ($virtualHeat['starts'] > $scheduled['starts'] && $virtualHeat['ends'] > $scheduled['ends']) || // Virtual start >= Scheduled Start && Virtual end >= Scheduled End ** Virtual starts during and ends after scheduled
                    ($virtualHeat['starts'] < $scheduled['starts'] && $virtualHeat['ends'] < $scheduled['ends']) || // Virtual start <= Scheduled Start && Virtual end <= Scheduled End ** Virtual starts before scheduled and ends during scheduled
                    ($virtualHeat['starts'] < $scheduled['starts'] && $virtualHeat['ends'] > $scheduled['ends']) // Virtual start <= Scheduled Start && Virtual end >= Scheduled End ** Virtual contains a scheduled
                ) {

                    // If this heat isn't already added, add it
                    $identifier = !isset($scheduled['HeatNo']) ? $scheduled['EventID'] : $scheduled['HeatNo'];
                    if(!in_array($identifier, $addedHeats)) {
                        $addedHeats[] = $identifier;
                        $heat = array(
                            'starts' => $scheduled['starts'],
                            'ends'   => $scheduled['ends'],
                            'status' => $status,
                            'spots'  => $scheduled['RacersPerHeat'],
                            'racers' => $scheduled['RacersPerHeat'] - $scheduled['SpotsAvailable'],
                            'title'  => $scheduled['title'],
                            'note'   => $scheduled['note']
                        );
                        if(isset($scheduled['HeatNo'])) {
                            $heat['heatId'] = $scheduled['HeatNo'];
                        } else {
                            $heat['eventId'] = $scheduled['EventID'];
                        };
                        $allHeats[] = $heat;
                    }
                    $doNotAdd = true;
                    break;
                }
            }

            if($doNotAdd == false) {
                // No existing heats found, so add the virtual heat
                $allHeats[] = $virtualHeat;
            }

        }

        // Remove heats marked as "closed" (status = 4)
        foreach($allHeats as $key => $heat) {
            if(isset($heat['status']) && $heat['status'] == 4) {
                unset($allHeats[$key]);
            }
        }

        // Sort by start time
        usort($allHeats, array("Races", "sort_heatStart"));

        return $allHeats;
    }

    public function races($trackId = null) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        $trackWhere = empty($trackId) ? '' : ' AND hm.TrackNo = ' . (int)$trackId;
        $tsql= "SELECT"
            ."\n    hm.HeatNo"
            ."\n    , hm.HeatStatus"
            ."\n    , hm.ScheduledTime"
            ."\n    , hm.HeatTypeNo"
            ."\n    , hm.LapsOrMinutes"
            ."\n    , hm.PointsNeeded"
            ."\n    , hm.RacersPerHeat"
            ."\n    , hm.TrackNo"
            ."\n    , hm.WinBy"
            ."\n    , hm.RaceBy"
            ."\n    , hm.ScheduleDuration"
            ."\n    , hm.SpeedLevel"
            ."\n    , COUNT(hd.HeatNo)"
            ."\nFROM HeatMain AS hm"
            ."\nLEFT OUTER JOIN HeatDetails AS hd ON hm.HeatNo = hd.HeatNo"
            ."\nWHERE (hm.ScheduledTime BETWEEN ? AND ?) $trackWhere"
            ."\nGROUP BY hm.HeatNo, hm.HeatStatus, hm.ScheduledTime, hm.HeatTypeNo, hm.LapsOrMinutes, hm.RacersPerHeat, hm.TrackNo, hm.WinBy, hm.RaceBy, hm.ScheduleDuration, hm.SpeedLevel, hm.PointsNeeded"
            ."\nORDER BY hm.ScheduledTime";

        // If no start date given, default to today
        if(!isset($_GET['start'])) {
            $start = date($GLOBALS['dateFormat']);
            $end   = date($GLOBALS['dateFormat'] . " H:i:s", strtotime(date($GLOBALS['dateFormat'], strtotime($start))) + 24*60*60); // End of today
        }

        // Otherwise, use range given (defaulting to end of day if no end is given
        else {
            $start = date($GLOBALS['dateFormat'] . " H:i:s", strtotime($_GET['start']));
            $end = isset($_GET['end']) ? date($GLOBALS['dateFormat'] . " H:i:s", strtotime($_GET['end'])) : date($GLOBALS['dateFormat'] . " H:i:s", strtotime($start) + 24*60*60); // Use end, or make it the end of the start day given
        }

        $tsql_params = array(&$start, &$end);
        $rows = $this->run_query($tsql, $tsql_params);
        $output = $rows;

        foreach($output as $currentRaceIndex => $currentRace)
        {
            if (isset($currentRace['ScheduledTime']))
            {
                $output[$currentRaceIndex]['ScheduledTime'] = date($GLOBALS['dateFormat'] . " H:i:s", strtotime($currentRace['ScheduledTime']));
            }
        }

        return array('races' => $output);
    }

    //TODO: Check for "banana" input as date... perhaps in all of these methods.
    public function since() {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }
        $tsql = "SELECT TOP 100    hm.HeatNo AS race_id, hm.Finish AS finish_time
                FROM         HeatMain AS hm
                WHERE     (hm.Finish > ?)
                ORDER BY hm.Finish";

        $limit = 100;
        $replacements = 1;
        if(!isset($_GET['date'])) {
            throw new RestException(412,'Please provide a time ("date" as a URL variable) after which you\'d like to receive heats.');
        }
        else {
            $decimalPos = strpos($_GET['date'],'.');
            if ($decimalPos !== false && $decimalPos < strlen($_GET['date'])) //If there are milliseconds in the time
            {
                $milliseconds = substr($_GET['date'],$decimalPos + 1);
            }
            else
            {
                $milliseconds = "000";
            }
            $since = date($GLOBALS['dateFormat'] . " H:i:s", strtotime($_GET['date']));
            $since = $since . "." . $milliseconds;
        }

        if(isset($_GET['limit']))
        {
            if($_GET['limit'] > 500)
            {
                throw new RestException(412,'Cannot return more than 500 rows');
            }
            else
            {
                $limit = (int)$_GET['limit'];
                $tsql = str_replace("100",$limit,$tsql,$replacements); //TODO: HACK: Multiple parameters in $tsql_params wasn't working. Fix this.
            }
        }

        $tsql_params = array(&$since);

        $rows = $this->run_query($tsql, $tsql_params);

        $output = $rows;

        return array('races' => $output);
    }

    public function final_positions($heatNum = -1) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        $output = array();
        $trackId = -1;

        if (!isset($_GET["race_id"]))
        {
            throw new RestException(412,'Please provide a race_id as a URL parameter');
        }

        $heatNum = $_GET["race_id"];

        if(!is_numeric($heatNum) && !empty($heatNum)) throw new RestException(412,'race_id ' . ($heatNum) .  ' is not a valid number');


        $raceSummary = $this->raceSummary($heatNum);
        if ($raceSummary["id"] == null || $raceSummary["finish_time"] == null)
        {
            throw new RestException(412, 'This race never finished.');
        }
        $output["race_id"] = $raceSummary["id"];
        $output["finish_time"] = $raceSummary["finish_time"];

        $tsql = "EXEC GetScoreboard " . $trackId . "," . $heatNum;
        $scoreboard = $this->run_query($tsql, array());

        $positions = array();
        foreach($scoreboard as $currentRacer)
        {
            $currentRacerInfo = array();
            $currentRacerInfo["position"] = $currentRacer["position"];
            $currentRacerInfo["racer_id"] = $currentRacer["racer_id"];
            $currentRacerInfo["nickname"] = $currentRacer["nickname"];
            $currentRacerInfo["first_name"] = $currentRacer["first_name"];
            $currentRacerInfo["last_name"] = $currentRacer["last_name"];
            $currentRacerInfo["rpm"] = $currentRacer["rpm"];
            //TODO: Ask Wes - are more details desired, like racer names?
            $positions[] = $currentRacerInfo;

        }
        $output["final_positions"] = $positions;

        return array("race" => $output);

    }

    /**
     * Get the fastest lap times. Defaults to fastest of day on most recently run speedlevel/track
     * Requires public access
     * @param array $options Optional, date range, day, week, month, year, speed level, track id, number to return
     * @return array
     */
    public function fastest() {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        /*
        /results?range=day    " fastest of day
        /results?range=week   " fastest of week
        /results?range=month  " fastest of month
                /results?range=year   " fastest of year

        " Date range.
        /results?start=2012-01-01&end=2012-01-01

        " Tracks.
        /results?track=1

        " Speed Level.
        /results?speed_level=1

        " Limit results returned.
        /results?limit=5

        " Exclude employees
        /results?exclude_employees=1
        */

        $tsql_params = array();
        $tsql_range = '';
        $tsql_track = '';
        $tsql_weight= '';
        $tsql_gender= '';
        $tsql_speed_level = '';
        $tsql_exclude_employees = isset($_GET['exclude_employees']) && $_GET['exclude_employees'] == 0 ? false : true;
        $tsql_birthdate = '';

        if(isset($_GET['limit']) && is_numeric($_GET['limit'])) {
            if($_GET['limit'] > 100) throw new RestException(412,'Cannot return more than 100 rows');
            //$tsql_params[] = (int)$_GET['limit'];
            $limit = (int)$_GET['limit'];
        } else {
            //$tsql_params[] = 50;
            $limit = 50;
        }

        $starttime = '00:00:00';
        $endtime = '23:59:59';
        $isoDateFormat = 'Y-m-d';

        if(isset($_GET['range'])) {
            
            switch($_GET['range']) {
                case 'day':
                    $start = date($isoDateFormat) . 'T' . $starttime;
                    break;
                case 'week':
                    $start = date($isoDateFormat, strtotime('last Sunday')) . 'T' . $starttime;
                    break;
                case 'month':
                    $start = date($isoDateFormat, strtotime('first day of this month')) . 'T' . $starttime;
                    break;
                case 'year':
                    $start = date($isoDateFormat, strtotime('first day of january')) . 'T' . $starttime;
                    break;
                default:
                    throw new RestException(412,'Invalid range given');
            }
            $end = date($isoDateFormat) . 'T' . $endtime;
            $tsql_range = 'AND rd.TimeStamp BETWEEN ? AND ?';
            $tsql_params[] = &$start;
            $tsql_params[] = &$end;
        } elseif(isset($_GET['start']) && isset($_GET['end'])) {
            $start = date($isoDateFormat, strtotime($_GET['start'])) . 'T' . $starttime;
            $end = date($isoDateFormat, strtotime($_GET['end'])) . 'T' . $endtime;
            $tsql_range = 'AND rd.TimeStamp BETWEEN ? AND ?';
            $tsql_params[] = &$start;
            $tsql_params[] = &$end;
        }

        if(isset($_GET['track'])) {
            if(!is_numeric($_GET['track'])) throw new RestException(412,'Invalid track given');
            $tsql_track = 'AND hm.TrackNo = ?';
            $tsql_params[] = &$_GET['track'];
        }

        if(isset($_GET['gender'])) {
            $genders = array('m' => 1, 'f' => 2);
            if(!in_array(strtolower($_GET['gender']), array('m', 'f'))) throw new RestException(412,'Invalid gender given');
            $tsql_gender = 'AND c.Gender = ?';
            $tsql_params[] = &$genders[strtolower($_GET['gender'])];
        }

        if(isset($_GET['weight'])) {
            $weights = array('light' => 4, 'medium' => 5, 'heavy' => 10, 'sumo' => 11);
            if(!in_array($weights[$_GET['weight']], array(4,5,10,11))) throw new RestException(412,'Invalid weight given');
            $tsql_weight = 'AND c.Status3 = ?';
            $tsql_params[] = &$weights[$_GET['weight']];
        }

        if(isset($_GET['speed_level'])) {
            if(!is_numeric($_GET['speed_level'])) throw new RestException(412,'Invalid speed level given');
            $tsql_speed_level = 'AND hm.SpeedLevel = ?';
            $tsql_params[] = &$_GET['speed_level'];
        }

        if($tsql_exclude_employees) {
            $tsql_exclude_employees = 'AND c.IsEmployee = ?';
            $tsql_params[] = false;
        } else {
            $tsql_exclude_employees = '';
        }

        if(isset($_GET['start_birthdate']) && isset($_GET['end_birthdate'])) {
            $start_birthdate = date($GLOBALS['dateFormat'], strtotime($_GET['start_birthdate'])) . ' 12:00:00 AM';
            $end_birthdate = date($GLOBALS['dateFormat'], strtotime($_GET['end_birthdate'])) . ' 11:59:59 PM';
            $tsql_birthdate = 'AND c.BirthDate BETWEEN ? AND ?';
            $tsql_params[] = &$start_birthdate;
            $tsql_params[] = &$end_birthdate;
        }

        $tsql = <<<EOD
        SELECT DISTINCT TOP ($limit) MAX(rd.CustID) AS CustID, MAX(c.FName) AS FirstName, MAX(c.LName) AS LastName, MAX(c.RacerName) AS RacerName, MAX(c.RPM) AS rpm, MIN(rd.LTime) AS LTime, MAX(rd.TimeStamp) AS TimeStamp, MAX(rd.LapNum) AS LapNum, MAX(hm.SpeedLevel) AS SpeedLevel, MAX(hm.TrackNo) AS TrackNo, MIN(t.Description) AS TrackName, MAX(c.TotalRaces) AS TotalRaces
        FROM         RacingData AS rd LEFT OUTER JOIN
                              Customers AS c ON c.CustID = rd.CustID LEFT OUTER JOIN Tracks t ON TrackNo = t.TrackNo LEFT OUTER JOIN
                              HeatMain AS hm ON hm.HeatNo = rd.HeatNo 
        WHERE  (rd.LTime <> 0) AND (rd.IsBadTime <> 'true') $tsql_range $tsql_track $tsql_gender $tsql_weight $tsql_speed_level $tsql_exclude_employees $tsql_birthdate
        GROUP BY c.RacerName
        ORDER BY LTime
EOD;

        $rows = $this->run_query($tsql, $tsql_params);
        $output = array();
        foreach($rows as $row) {
            $output[] = array('racer_id' => $row['CustID'],
                'nickname' => $row['RacerName'],
                'first_name' => $row['FirstName'],
                'rpm' => $row['rpm'],
                'last_name' => $row['LastName'],
                'lap_time' => round($row['LTime'] / 1000, 3),
                'lap_number' => $row['LapNum'],
                'total_races' => $row['TotalRaces'],
                'speed_level' => $row['SpeedLevel'],
                'track_id' => $row['TrackNo'],
                'track_name' => $row['TrackName'],
                'timestamp' => date($GLOBALS['dateFormat'] . ' H:i:s', strtotime($row['TimeStamp'])),
                                'photo_url' => $this->getCustomerPhoto($row['CustID'])
            );

        }

        return array('fastest' => $output);
    }

    public function scoreboard($trackId = -1, $heatNum = -1) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        $race = array();

        if(!is_numeric($trackId) && !empty($trackId)) throw new RestException(412,'track_id is not a valid number');
        if(!is_numeric($heatNum) && !empty($heatNum)) throw new RestException(412,'heat_id ' . ($heatNum) .  ' is not a valid number');

        // Searching by heat
        if(empty($trackId)) {
            $trackId = -1;
            $race = $this->raceSummary($heatNum);
        }

        // Searching by track
        if(empty($heatNum)) {
            $heatNum = -1;
            $race = $this->raceSummary($this->current($trackId));
        }

        $output = array();
        $tsql = "EXEC GetScoreboard " . $trackId . "," . $heatNum;
        $scoreboard = $this->run_query($tsql, array());
        return array('race' => $race, 'scoreboard' => $scoreboard);

    }

    public function raceSummary($heatId) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        $tsql = "SELECT hm.*, ht.HeatTypeName, sl.Description AS sl_Description, t.Description AS t_Description FROM HeatMain hm LEFT JOIN HeatTypes ht ON ht.HeatTypeNo = hm.HeatTypeNo LEFT JOIN Tracks t ON t.TrackNo = hm.TrackNo LEFT JOIN SpeedLevel sl ON hm.SpeedLevel = sl.SpeedLevel WHERE HeatNo = ?";
        $heat = $this->run_query($tsql, array(&$heatId));

        $win_by  = array(0 => 'laptime', 1 => 'position');
        $race_by = array(0 => 'minutes', 1 => 'laps');

        foreach($heat as $row) {

            if($row['HeatStatus'] == 1) {
                if($row['RaceBy'] == 0) {
                    $tsql = "select top 1 datediff(ms, timestamp, current_timestamp) as time from racingdata where heatno = ? order by timestamp";
                    $raceTimeInSeconds = $this->run_query($tsql, array(&$heatId));
                    $raceTimeInSeconds = isset($raceTimeInSeconds[0]) && array_key_exists('time',$raceTimeInSeconds[0]) ? $raceTimeInSeconds[0]['time'] / 1000 : null;
                    //TODO: Evaluate this functionality. At the moment the details are being handled by the user of the API.
                } else {
                    $tsql = "select top 1 datediff(ms, timestamp, current_timestamp) as time from racingdata where heatno = ? order by timestamp";
                    $raceTimeInSeconds = $this->run_query($tsql, array(&$heatId));
                    $raceTimeInSeconds = isset($raceTimeInSeconds[0]) && array_key_exists('time',$raceTimeInSeconds[0]) ? $raceTimeInSeconds[0]['time'] / 1000 : null;
                }

            } else {
                $raceTimeInSeconds = null;
            }

            $output = array('id' => $row['HeatNo'],
                'track_id' => $row['TrackNo'],
                'track' => $row['t_Description'],
                'starts_at' => date($GLOBALS['dateFormat'] . ' H:i:s', strtotime($row['ScheduledTime'])),
                'finish_time' => date($GLOBALS['dateFormat'] . ' H:i:s', strtotime($row['Finish'])),
                'heat_type_id' => $row['HeatTypeNo'],
                'heat_status_id' => $row['HeatStatus'],
                'speed_level_id' => $row['SpeedLevel'],
                'speed_level' => $row['sl_Description'],
                'win_by' => $win_by[$row['WinBy']],
                'race_by' => $race_by[$row['RaceBy']],
                'duration' => $row['RaceBy'] == 0 ? $row['LapsOrMinutes']/60 : $row['LapsOrMinutes'],
                'race_name' => $row['HeatTypeName'],
                'race_time_in_seconds' => $raceTimeInSeconds
            );
        }
        return @$output;
    }

    /**
     * Get the racers, laps and other details of a heat
     * Requires public access
     * @param integer $heatId Optional, heat to return, defaults to currently running heat
     * @return array
     */
    public function race($heatId) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        if(!is_numeric($heatId) && !in_array($heatId, array('current', 'next'))) throw new RestException(412,'Heat ID is not a number, "next" or "current"');
        $output = array();

        //$tsql = 'GetNextHeatInfo';
        $track_id = (isset($_GET['track']) && is_numeric($_GET['track'])) ? (int)$_GET['track'] : 1;
        if (is_numeric($heatId))
        {
            $tsql = 'GetHeatInfoByHeatNo' . ' ' . $heatId;
        }
        else
        {
            $tsql = 'GetNextHeatInfo' . ' ' . $track_id;
        }
        //$tsql_params = array(&$track_id);
        $rowsRace = $this->run_query($tsql);
        if (empty($rowsRace))
            throw new RestException(412, 'Unable to find any racing data for track: ' . $track_id . ', heat: ' . $heatId);

        $output['race'] = $rowsRace[0];
        if (isset($output['race']['starts_at']))
        {
            $output['race']['starts_at_iso'] = $output['race']['starts_at'];
            $output['race']['starts_at'] = date($GLOBALS['dateFormat'] . ' H:i:s', strtotime($output['race']['starts_at']));
        }
        $output['race']['race_number'] = substr($output['race']['id'], -2); // Race Number is the last two digits of the ID

        //$tsql = 'GetNextHeatRacersInfo';
        $tsql_params = array(&$heatId);
        $tsql = 'Select hd.CustID id, hd.RPMDiff AS rpm_change, hd.LineUpPosition start_position, CASE autono WHEN -1 then hd.historyautono ELSE autono END AS kart_number, hd.RPM rpm, case when c.TotalRaces > 1 then 0 else 1 end is_first_time, hd.FinishPosition finish_position, c.RacerName nickname, c.FName first_name, c.LName last_name From HeatMain hm inner join HeatTypes ht on hm.HeatTypeNo = ht.HeatTypeNo inner join SpeedLevel sl on hm.SpeedLevel = sl.SpeedLevel inner join Tracks t on hm.trackno = t.TrackNo inner join HeatDetails hd on hm.heatno = hd.heatno inner join Customers c on hd.CustID = c.CustID Where hd.HeatNo = ? order by hd.LineUpPosition';
        $rowsRacers = $this->run_query($tsql, $tsql_params);
        $output['race']['racers'] = $rowsRacers;

        foreach($output['race']['racers'] as $key => $racer) {
            $racerInfo = $this->run_query('GetRacerProfile '.(int)$racer['id'].', ' . (int)$heatId, array());
            $output['race']['racers'][$key]['total_customers'] = $racerInfo[0]['TotalCustomers'];
            $output['race']['racers'][$key]['ranking_by_rpm'] = $racerInfo[0]['RankingByRPM'];
            $output['race']['racers'][$key]['group_id'] = $racerInfo[0]['GroupID'];
            $output['race']['racers'][$key]['total_visits'] = $racerInfo[0]['TotalVisits'];
            $output['race']['racers'][$key]['total_races'] = $racerInfo[0]['TotalRaces'];
            $output['race']['racers'][$key]['photo_url'] = $this->getCustomerPhoto($racer['id']);
        }

        if (is_numeric($heatId)) //TODO: Document and explain the SQL 2005 hacks
        {
            $tsql = "SELECT * FROM RacingData WHERE HeatNo = " . $heatId . " AND IsBadTime = 0";
            $laps = $this->run_query($tsql);
            
            // Build mapping between customer id and the key in the array
            $racersToKeys = array();
            foreach($output['race']['racers'] as $key => $racer) {
                $racersToKeys[$racer['id']] = $key;
            }

            foreach($laps as $lap) {
                $currentLap = array(
                    'id' => $lap['ID'],
                    'kart_number' => $lap['AutoNo'],
                    'lap_time' => $lap['LTime']/1000,
                    'amb_time' => $lap['AMBTime']/1000,
                    'lap_number' => $lap['LapNum'],
                    'racer_id' => $lap['CustID']
                );
                
                $key = $racersToKeys[$currentLap['racer_id']];
                $output['race']['racers'][$key]['laps'][] = $currentLap;
                $output['race']['laps'][] = $currentLap;
            }

            if(isset($output['race']['laps'])) {
                $output = $output + $this->scoreboard(-1, (int)($heatId));
            }
        }

        return $output;
    }

    /**
     * Get # of passings from a heat
     * Requires public access
     * @param integer $heatId Optional, heat to return, defaults to currently running heat
     * @return array
     */
    public function number_of_laps($heatId = null) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        // If heatId == null, get current heat

        $tsql_params = array(&$heatId);

        $tsql = "SELECT COUNT(*) AS passes FROM RacingData WHERE HeatNo = ? AND IsBadTime = 0";
        $laps = $this->run_query($tsql, $tsql_params);

        $output = $laps[0]['passes'];

        return array('laps' => $output);
    }

    /**
     * Get the laps from a heat
     * Requires public access
     * @param integer $heatId Optional, heat to return, defaults to currently running heat
     * @param integer $lapId Optional, returns only laps after lap id.
     * @param integer $racerId Optional, returns only laps for this racer id.
     * @return array
     */
    protected function laps($heatId = null, $lapId = 0, $racerId = null) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }

        // If heatId == null, get current heat

        $tsql_params = array(&$heatId, &$lapId);

        $racerId_tsql = '';
        if($racerId !== null) { // Limit by racerId
            $racerId_tsql = 'AND CustID = ?';
            $tsql_params[] = &$racerId;
        }
        $tsql = "SELECT * FROM RacingData WHERE HeatNo = ? AND IsBadTime = 0 AND ID > ? $racerId_tsql";
        $laps = $this->run_query($tsql, $tsql_params);

        $output = array();
        foreach($laps as $lap) {
            $output[] = array(
                'id' => $lap['ID'],
                'kartNo' => $lap['AutoNo'],
                'lapTime' => $lap['LTime']/1000,
                'lapNum' => $lap['LapNum'],
                'racerId' => $lap['CustID']
            );
        }

        return array('laps' => $output);
    }

    /**
     * Get the url to the customer's picture (if it exists)
     * Requires public access
     * @param integer $racer_id Required, id to lookup picture for
     * @return string (url to photo) or null (no photo found)
     */
    public function getCustomerPhoto($racer_id) {
        if (!\ClubSpeed\Security\Authenticate::publicAccess()) {
            throw new RestException(401, "Invalid authorization!");
        }
        
        if(empty($this->CustomerPicturesPath)) {
            // Get the path and URL to the customer pictures
            $settings = new Settings();
            $pictureSettings = $settings->getSettings('MainEngine', array('CustomerPicturesPath', 'CustIDPicPath'));
            $this->CustomerPicturesPath = @$pictureSettings['settings']['CustomerPicturesPath']['SettingValue'];
        }
    
        // See if this customer has a picture
        $customerPictureURL = null;
        $customerPicturePath = $this->CustomerPicturesPath . '\\' . $racer_id . '.jpg';
        $host = empty($_SERVER['HTTPS']) || $_SERVER['HTTPS'] == 'off' ? 'http://' . $_SERVER['HTTP_HOST'] : 'https://' . $_SERVER['HTTP_HOST'];
        if(file_exists($customerPicturePath)) {
            $customerPictureURL = $host . '/CustomerPictures/' . $racer_id . '.jpg'; // Path hardcoded in Club Speed
        }
        
        return $customerPictureURL;
    }

    private function run_query($tsql, $params = array()) {
    $tsql_original = $tsql . ' ';
        // Connect
        try {
            $conn = new PDO( "sqlsrv:server=(local) ; Database=ClubSpeedV8", "", "");
            $conn->setAttribute( PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION );

/*            if ($tsql == "GetNextHeatInfo ?")
            {
                $tsql = "GetNextHeatInfo 1";
            }

            if ($tsql == "GetNextHeatRacersInfo ?")
            {
                $tsql = "GetNextHeatRacersInfo 1";
            }*/

            // Prepare statement
            $stmt = $conn->prepare($tsql);

            // Execute statement

            $stmt->execute($params);

            // Put in array
            $output = $stmt->fetchAll(PDO::FETCH_ASSOC);

        } catch(Exception $e) {
            die('Exception Message:'  . $e->getMessage()  . '<br/>(Line: '. $e->getLine() . ')' . '<br/>Passed query: ' . $tsql_original . '<br/>Parameters passed: ' . print_r($params,true));
        }

        return $output;
    }

}