<?php
/**
 * Club Speed API
 *
 * Proposed API for accessing racer, heat and scoring information
 * generated by Club Speed server.
 * @author Wes Ratcliff <wes@clubspeed.com>
 * @version 0.1
 */

/**
 * /races/next
 * /races/fastest
 */
class Races
{
    public $restler;

    function __construct(){
        header('Access-Control-Allow-Origin: *'); //Here for all /say
    }


    protected function index($race_id, $sub = null) {
        //if(!is_numeric($race_id) || $race_id !== 'current') throw new RestException(412,'Not a valid race id');

        if($race_id == 'current_race_id') return $this->current();
        if($race_id == 'current') $race_id = $this->current();
        if($race_id == 'fastest') return $this->fastest();
        if($race_id == 'next') return $this->next(@$_GET['track_id'], @$_GET['offset']);
        if($race_id == 'total_laps') return $this->total_laps();
        if($race_id == 'lap_number') return $this->lap_number($sub);
        if($race_id == 'scoreboard') return $this->scoreboard(@$_GET['track_id'], @$_GET['heat_id']);
        if($race_id == 'races') return $this->races();
        if($race_id == 'since') return $this->since();
        if($race_id == 'final_positions') return $this->final_positions();
        if($race_id == 'matching') return $this->matching();
				if($race_id == 'upcoming') return $this->upcoming();

        if($sub != null) {
            switch($sub) {
                case 'current':
                    return $race_id;
                    break;
                case 'laps':
                    $_GET['lap_id'] = isset($_GET['lap_id']) ? $_GET['lap_id']: 0;
                    $_GET['racer_id'] = isset($_GET['racer_id']) ? $_GET['racer_id']: null;
                    return $this->laps($race_id, $_GET['lap_id'], $_GET['racer_id']);
                    break;
                case 'number_of_laps':
                    return $this->number_of_laps($race_id);
                    break;
            }
        } else {
            return $this->race($race_id);
        }
    }

    protected function total_laps() {
        $tsql = "SELECT COUNT(*) AS total_laps FROM RacingData";
        $tsql_params = array();

        $rows = $this->run_query($tsql, $tsql_params);

        $output = array();

        if(count($rows)) {
            return $rows;
        } else {
            $_GET['suppress_response_codes'] = true;
            throw new RestException(412, 'No results returned.');
        }
    }

    protected function lap_number($num) {
        if(empty($num) || !is_numeric($num)) {
            $_GET['suppress_response_codes'] = true;
            throw new RestException(412, 'No lap number given.');
        }
        $tsql = "WITH Records AS (SELECT row_number() OVER (ORDER BY ID) AS 'row', rd.*, c.FName, c.LName FROM RacingData rd LEFT JOIN Customers c ON rd.CustID = c.CustID) SELECT * FROM records WHERE row = ?";
        $tsql_params = array(&$num);

        $row = $this->run_query($tsql, $tsql_params);

        $output = array();

        if(count($row)) {
            //return $row;
            return array('lap_number' => $row[0]['row'],
                'lap_id'     => $row[0]['ID'],
                'first_name' => $row[0]['FName'],
                'last_name'  => $row[0]['LName'],
                'racer_id'   => $row[0]['CustID'],
                'lap_time'   => round($row[0]['LTime'] / 1000, 3),
                'race_id'    => $row[0]['HeatNo']);
        } else {
            $_GET['suppress_response_codes'] = true;
            throw new RestException(412, 'No results returned.');
        }
    }

    /**
     * This function returns the next upcoming heat's id, or error code 412 if
     * no races are coming up. Note that if a track is running behind, this method will not return
     * the next heat if the time for it to have started has already passed. This is a limitation of
     * the stored procedure being used.
     *
     * @param null $track The track to pull data from. Currently being unused.
     * @param int $nextNum See Wes. Currently being unused.
     * @return mixed The 'id' field of the next heat coming up.
     * @throws RestException Error code 412 is returned if no races are coming up.
     *
     */
    protected function upcoming($track = null) {
				$track_id = (isset($_GET['track']) && is_numeric($_GET['track'])) ? (int)$_GET['track'] : 1; // Default to Track 1
				$return = array('races' => array());

				$tsql = 'SELECT * FROM HeatMain WHERE TrackNo = ? AND HeatStatus IN (0,4) AND ScheduledTime > (SELECT TOP(1) hm.ScheduledTime AS starts_at FROM HeatMain hm WHERE hm.TrackNo = ? AND hm.HeatStatus IN (1,2,3) ORDER BY hm.ScheduledTime DESC)';
				$tsql_params = array(&$track_id, &$track_id);
				$upcomingRaces = $this->run_query($tsql, $tsql_params);
				
				forEach($upcomingRaces as $id => $race) {
					$return['races'][] = $this->race($race['HeatNo']);
				}
				
        return $return;
		}
		
		protected function next($track = null, $offset = 0) {

				$track_id = (isset($_GET['track']) && is_numeric($_GET['track'])) ? (int)$_GET['track'] : 1; // Default to Track 1
				$offset = (int)$offset + 1; // Modify to match SQL Server where 1 = First Row

				$tsql = 'WITH CTE AS (SELECT *, ROW_NUMBER() OVER (ORDER BY ScheduledTime) AS Rank FROM HeatMain WHERE TrackNo = ? AND HeatStatus IN (0,4) AND ScheduledTime > (SELECT TOP(1) hm.ScheduledTime AS starts_at FROM HeatMain hm WHERE hm.TrackNo = ? AND hm.HeatStatus IN (1,2,3) ORDER BY hm.Begining DESC)) SELECT c.* FROM CTE c WHERE Rank = ?';
				$tsql_params = array(&$track_id, &$track_id, &$offset);
				$rows = $this->run_query($tsql, $tsql_params);
				
				if(empty($rows[0]['HeatNo'])) {
					throw new RestException(412, 'No upcoming race found.');
				} else {
					$nextHeatId = $rows[0]['HeatNo'];
				}
				
        return $this->race($nextHeatId);

    }

    protected function current($track = null) {
        $track_id = (isset($_GET['track_id']) && is_numeric($_GET['track_id'])) ? (int)$_GET['track_id'] : 1;
        $tsql = "SELECT HeatNo FROM HeatMain WHERE (HeatStatus = 1) AND (TrackNo = ?)";
        $tsql_params = array(&$track_id);

        $rows = $this->run_query($tsql, $tsql_params);

        $output = array();

        if(count($rows)) {
            return $rows[0]['HeatNo'];
        } else {
            $_GET['suppress_response_codes'] = true;
            throw new RestException(412, 'Race not currently running');
        }
    }

    protected function matching() {
        $tsql_heatType = '';
        $tsql_numSpots = '';

        $blackoutTime = 1*60; // In minutes
        $maximumDaysOut = 365; // In days

        // If no start date given, default to today
        if(!isset($_GET['start'])) {
            $start = date($GLOBALS['dateFormat'] . " H:i:s");
            $end   = date($GLOBALS['dateFormat'] . " H:i:s", strtotime(date($GLOBALS['dateFormat'], strtotime($start))) + 24*60*60); // End of today
        }

        // Otherwise, use range given (defaulting to end of day if no end is given
        else {
            $start = date($GLOBALS['dateFormat'] . " H:i:s", strtotime($_GET['start']));
            $end = isset($_GET['end']) ? date($GLOBALS['dateFormat'] . " H:i:s", strtotime($_GET['end'])) : date($GLOBALS['dateFormat'] . " H:i:s", strtotime($start) + 24*60*60); // Use end, or make it the end of the start day given
        }

        // Change start to enforce the blackout time
        /*$cannotScheduleBefore = time() + $blackoutTime*60;
        if(strtotime($start) < $cannotScheduleBefore) {
            $start = date("Y-m-d H:i:s", $cannotScheduleBefore);
        }*/

        // Check to ensure we are not scheduling in the past
        /*if(strtotime($end) < time()) {
            throw new RestException(412,'Cannot schedule events in the past');
        }*/

        // Check to ensure we are not scheduling too far ahead
        $maximumSecondsOut = time() + $maximumDaysOut*24*60*60;
        if(strtotime($end) > $maximumSecondsOut || strtotime($start) > $maximumSecondsOut) {
            throw new RestException(412,'Cannot schedule more than ' . $maximumDaysOut . ' in advance');
        }

        $tsql_params = array(&$start, &$end);

        if(isset($_GET['heatType']) && is_numeric($_GET['heatType'])) {
            $tsql_heatType = 'AND hm.HeatTypeNo = ?';
            $tsql_params[] = &$_GET['heatType'];
        }

        $tsql = "SELECT hm.HeatNo, ht.HeatTypeName AS title, hm.HeatNotes AS note, hm.HeatStatus, hm.ScheduledTime AS starts, hm.HeatTypeNo, hm.LapsOrMinutes, hm.RacersPerHeat, hm.TrackNo, hm.WinBy, hm.RaceBy, hm.ScheduleDuration,
                      hm.SpeedLevel, (hm.RacersPerHeat - (hm.NumberOfReservation + hm.NumberOfCadetReservation + COUNT(hd.HeatNo))) AS SpotsAvailable, COUNT(hd.HeatNo) AS NumberOfPaid, hm.NumberOfReservation, hm.NumberOfCadetReservation
FROM         HeatMain AS hm LEFT OUTER JOIN
                      HeatDetails AS hd ON hm.HeatNo = hd.HeatNo
                      LEFT OUTER JOIN HeatTypes AS ht ON hm.HeatTypeNo = ht.HeatTypeNo
WHERE     (hm.ScheduledTime BETWEEN ? AND ?)  $tsql_heatType $tsql_numSpots
GROUP BY hm.HeatNo, ht.HeatTypeName, hm.HeatNotes, hm.HeatStatus, hm.ScheduledTime, hm.HeatTypeNo, hm.LapsOrMinutes, hm.RacersPerHeat, hm.TrackNo, hm.WinBy, hm.RaceBy, 
                      hm.ScheduleDuration, hm.SpeedLevel, hm.NumberOfReservation, hm.NumberOfCadetReservation  ORDER BY hm.ScheduledTime";

        $scheduledHeats = $this->run_query($tsql, $tsql_params);

        $tsql = "SELECT e.EventID, e.EventDesc as title, e.EventNotes as note, e.EventScheduledTime as starts, e.EventDuration as ScheduleDuration, e.TotalRacers as RacersPerHeat, e.MemberOnly as SpotsAvailable FROM Events e WHERE EventScheduledTime BETWEEN ? AND ?";
        $tsql_params = array(&$start, &$end);
        $scheduledEvents = $this->run_query($tsql, $tsql_params);

        // TODO Get from DB
        $bookingsStartAt = date($GLOBALS['dateFormat'], strtotime($start)) . ' 11:00:00';
        $bookingsEndAt   = date($GLOBALS['dateFormat'], strtotime($start)) . ' 12:30:00';
        $bookingLengthInMinutes = 20;
        $defaultSpots = 10;
        $trackId = 4;
        $daysInAdvance = 7;
        $blackoutTimeInMinutes = 0;

        $combinedEventsAndHeats = array_merge($scheduledHeats, $scheduledEvents);
        //print_r($combinedEventsAndHeats); die();

        $allHeats = $this->getHeatSlotsForDay($combinedEventsAndHeats, $start, $bookingsStartAt, $bookingsEndAt, $bookingLengthInMinutes, $defaultSpots, $trackId, $daysInAdvance, $blackoutTimeInMinutes);

//print_r($allHeats);die();

        if(!isset($_GET['numDrivers'])   || !is_numeric($_GET['numDrivers']))   throw new RestException(412,'Please provide the number of drivers (numDrivers)');
        if(!isset($_GET['numHeats'])     || !is_numeric($_GET['numHeats']))     throw new RestException(412,'Please provide the number of heats (numHeats)');
        if(!isset($_GET['gapInMinutes']) || !is_numeric($_GET['gapInMinutes'])) throw new RestException(412,'Please provide the gap in minutes (gapInMinutes)');
        $numDrivers   = isset($_GET['numDrivers']) ? $_GET['numDrivers'] : 1;
        $numHeats     = isset($_GET['numHeats']) ? $_GET['numHeats'] : 1;
        $gapInMinutes = isset($_GET['gapInMinutes']) ? $_GET['gapInMinutes'] : 10;

        $matchingHeats = $this->findMatchingHeats($allHeats, $numDrivers, $numHeats, $gapInMinutes);

        $matches = array();
        foreach($matchingHeats as $key => $match) {
            foreach($match as $heatKey => $heat) {
                $matches[$key][$heatKey] = array(
                    'heatId' => isset($heat['heatId']) ? $heat['heatId'] : null,
                    'starts' => date($GLOBALS['dateFormat'] . ' H:i:s', $heat['starts']),
                    'ends'   => date($GLOBALS['dateFormat'] . ' H:i:s', $heat['ends']),
                    'spots'  => $heat['spots'],
                    'racers' => $heat['racers'],
                    'title'  => $heat['title'],
                    'note'   => $heat['note']
                );
            }
        }

        return array('races' => $matches);
    }

    protected function sort_heatStart($a, $b) {
        $adist = intval($a['starts']);
        $bdist = intval($b['starts']);

        if ($adist == $bdist) {
            return 0;
        }
        return ($adist < $bdist) ? -1 : 1;
    }


    protected function findMatchingHeats($heats, $numDrivers, $numHeats, $gapInMinutes) {

        //usort($heats, array("Races", "sort_heatStart"));

        $availableHeats = array();

        // Once we have the slots, loop through them and see if the pattern we needs can be fulfilled for each one
        foreach($heats as $heat) {

            $potentialHeats = array(); // Heats that match what we're looking for
            // Check to see if the heat in question has enough slots for our drivers (if so, we can proceed further)
            $spotsAvailable = $heat['spots'] - $heat['racers'];

            if($spotsAvailable >= $numDrivers) {
                $potentialHeats[] = $heat; // Put in the first heat;

                // For multiple heat events, add heats that match the criteria to an array
                for($i = 1; $i < $numHeats; $i++) {

                    // Get the heat before this one so we can calculate the next heat needed in the sequence
                    $previousHeat = $potentialHeats[count($potentialHeats) - 1];

                    $nextHeatTime  = $previousHeat['ends'] + ($gapInMinutes * 60);
                    $potentialHeat = $this->findHeat($nextHeatTime, $heats);

                    // If heat is not available or exists but doesn't have spots, abort
                    if(empty($potentialHeat) || $numDrivers > ($potentialHeat['spots'] - $potentialHeat['racers'])) {
                        break;
                    }

                    $potentialHeats[] = $potentialHeat;

                }
            };

            // We have the correct amount of heats that match the criteria, so add them to the available heats
            if(count($potentialHeats) == $numHeats)
                $availableHeats[] = $potentialHeats;

        }

        return $availableHeats;
    }


    protected function findHeat($starts, $heats) {
        // Loop heats -- if we find a match, return it, otherwise return null
        foreach($heats as $heat) {
            if($heat['starts'] == $starts)
                return $heat;
        }
    }


    protected function getHeatSlotsForDay($scheduledHeats, $date, $bookingsStartAt, $bookingsEndAt, $bookingLengthInMinutes = 10, $defaultSpots = 25, $trackId = 0, $daysInAdvance = 365, $blackoutTimeInMinutes = 0) {
        $allHeats = array();
        $addedHeats = array();

        $numHeats = floor((strtotime($bookingsEndAt) - strtotime($bookingsStartAt)) / ($bookingLengthInMinutes * 60));

        for($i = 0; $i < $numHeats; $i++) {

            // Create virtual heat
            $virtualHeatTime = strtotime($bookingsStartAt) + ($i * $bookingLengthInMinutes * 60);
            $virtualHeat = array(
                'starts' => $virtualHeatTime,
                'ends' => $virtualHeatTime + ($bookingLengthInMinutes * 60),
                'spots' => $defaultSpots,
                'racers' => 0,
                'title' => 'Virtual',
                'note' => 'Virtual note'
            );

            $doNotAdd = false;

            // Loop through scheduled heats -- if an overlap exists, do not add the virtual
            foreach($scheduledHeats as $key => $scheduled) {


                // Convert scheduled starting and ending into seconds
                $scheduled['starts'] = strtotime($scheduled['starts']);
                $scheduled['ends']   = $scheduled['starts'] + ($scheduled['ScheduleDuration'] * 60);
                $status = isset($scheduled['HeatStatus']) ? $scheduled['HeatStatus'] : null;

                $identifier = !isset($scheduled['HeatNo']) ? $scheduled['EventID'] : $scheduled['HeatNo'];
                if(!in_array($identifier, $addedHeats)) {
                    if($scheduled['ends'] <= strtotime($bookingsStartAt)) { // If the scheduled heat ends before the booking time starts, add it to the array
                        $addedHeats[] = $identifier;
                        $allHeats[] = array(
                            //'heatId' => $scheduled['HeatNo'],
                            'starts' => $scheduled['starts'],
                            'status' => $status,
                            'ends'   => $scheduled['ends'],
                            'spots'  => $scheduled['RacersPerHeat'],
                            'racers' => $scheduled['RacersPerHeat'] - $scheduled['SpotsAvailable'],
                            'title'  => $scheduled['title'],
                            'note'   => $scheduled['note']
                        );
                    } elseif($scheduled['starts'] >= strtotime($bookingsEndAt)) { // If the scheduled heat starts after the booking time ends, add it to the array
                        $addedHeats[] = $identifier;
                        $allHeats[] = array(
                            //'heatId' => $scheduled['HeatNo'],
                            'starts' => $scheduled['starts'],
                            'status' => $status,
                            'ends'   => $scheduled['ends'],
                            'spots'  => $scheduled['RacersPerHeat'],
                            'racers' => $scheduled['RacersPerHeat'] - $scheduled['SpotsAvailable'],
                            'title'  => $scheduled['title'],
                            'note'   => $scheduled['note']
                        );
                    }
                }

                // Check if virtual heat overlaps
                /*if($virtualHeat['starts'] == $scheduled['starts'] && $virtualHeat['ends'] == $scheduled['ends'] // Start and end at same time
                        || (($virtualHeat['starts'] > $scheduled['starts']) && $virtualHeat['starts'] < $scheduled['ends']) // Virtual starts in the middle of existing heat
                        || (($virtualHeat['ends']   > $scheduled['starts']) && $virtualHeat['ends']   < $scheduled['ends']) // Virtual ends in middle of existing heat
                        ) {*/
                if(
                    ($virtualHeat['starts'] >= $scheduled['starts'] && $virtualHeat['ends'] <= $scheduled['ends']) || // Virtual start >= Scheduled Start && Virtual end <= Scheduled End **Virtual within scheduled or same duration
                    ($virtualHeat['starts'] > $scheduled['starts'] && $virtualHeat['ends'] > $scheduled['ends']) || // Virtual start >= Scheduled Start && Virtual end >= Scheduled End ** Virtual starts during and ends after scheduled
                    ($virtualHeat['starts'] < $scheduled['starts'] && $virtualHeat['ends'] < $scheduled['ends']) || // Virtual start <= Scheduled Start && Virtual end <= Scheduled End ** Virtual starts before scheduled and ends during scheduled
                    ($virtualHeat['starts'] < $scheduled['starts'] && $virtualHeat['ends'] > $scheduled['ends']) // Virtual start <= Scheduled Start && Virtual end >= Scheduled End ** Virtual contains a scheduled
                ) {

                    // If this heat isn't already added, add it
                    $identifier = !isset($scheduled['HeatNo']) ? $scheduled['EventID'] : $scheduled['HeatNo'];
                    if(!in_array($identifier, $addedHeats)) {
                        $addedHeats[] = $identifier;
                        $heat = array(
                            'starts' => $scheduled['starts'],
                            'ends'   => $scheduled['ends'],
                            'status' => $status,
                            'spots'  => $scheduled['RacersPerHeat'],
                            'racers' => $scheduled['RacersPerHeat'] - $scheduled['SpotsAvailable'],
                            'title'  => $scheduled['title'],
                            'note'   => $scheduled['note']
                        );
                        if(isset($scheduled['HeatNo'])) {
                            $heat['heatId'] = $scheduled['HeatNo'];
                        } else {
                            $heat['eventId'] = $scheduled['EventID'];
                        };
                        $allHeats[] = $heat;
                    }
                    $doNotAdd = true;
                    break;
                }
            }

            if($doNotAdd == false) {
                // No existing heats found, so add the virtual heat
                $allHeats[] = $virtualHeat;
            }

        }

        // Remove heats marked as "closed" (status = 4)
        foreach($allHeats as $key => $heat) {
            if(isset($heat['status']) && $heat['status'] == 4) {
                unset($allHeats[$key]);
            }
        }

        // Sort by start time
        usort($allHeats, array("Races", "sort_heatStart"));

        return $allHeats;
    }

    protected function races($trackId = null) {
        $trackWhere = empty($trackId) ? '' : ' AND hm.TrackNo = ' . (int)$trackId;
				
				$tsql = "SELECT hm.HeatNo, hm.HeatStatus, hm.ScheduledTime, hm.HeatTypeNo, hm.LapsOrMinutes, hm.RacersPerHeat, hm.TrackNo, hm.WinBy, hm.RaceBy, hm.ScheduleDuration, hm.SpeedLevel, COUNT(hd.HeatNo) AS Racers
FROM HeatMain AS hm
LEFT OUTER JOIN HeatDetails AS hd ON hm.HeatNo = hd.HeatNo
WHERE (hm.ScheduledTime BETWEEN ? AND ?) $trackWhere
GROUP BY hm.HeatNo, hm.HeatStatus, hm.ScheduledTime, hm.HeatTypeNo, hm.LapsOrMinutes, hm.RacersPerHeat, hm.TrackNo, hm.WinBy, hm.RaceBy, hm.ScheduleDuration, hm.SpeedLevel ORDER BY hm.ScheduledTime";

        // If no start date given, default to today
        if(!isset($_GET['start'])) {
            $start = date($GLOBALS['dateFormat'] . " H:i:s");
            $end   = date($GLOBALS['dateFormat'] . " H:i:s", strtotime(date($GLOBALS['dateFormat'], strtotime($start))) + 24*60*60); // End of today
        }

        // Otherwise, use range given (defaulting to end of day if no end is given
        else {
            $start = date($GLOBALS['dateFormat'] . " H:i:s", strtotime($_GET['start']));
            $end = isset($_GET['end']) ? date($GLOBALS['dateFormat'] . " H:i:s", strtotime($_GET['end'])) : date($GLOBALS['dateFormat'] . " H:i:s", strtotime($start) + 24*60*60); // Use end, or make it the end of the start day given
        }

        $tsql_params = array(&$start, &$end);

        $rows = $this->run_query($tsql, $tsql_params);

        $output = $rows;

        return array('races' => $output);
    }

    //TODO: Check for "banana" input as date... perhaps in all of these methods.
    protected function since() {
        $tsql = "SELECT TOP 100    hm.HeatNo AS race_id, hm.Finish AS finish_time
                FROM         HeatMain AS hm
                WHERE     (hm.Finish > ?)
                ORDER BY hm.Finish";

        $limit = 100;
        $replacements = 1;
        if(!isset($_GET['date'])) {
            throw new RestException(412,'Please provide a time ("date" as a URL variable) after which you\'d like to receive heats.');
        }
        else {
            $decimalPos = strpos($_GET['date'],'.');
            if ($decimalPos !== false && $decimalPos < strlen($_GET['date'])) //If there are milliseconds in the time
            {
                $milliseconds = substr($_GET['date'],$decimalPos + 1);
            }
            else
            {
                $milliseconds = "000";
            }
            $since = date($GLOBALS['dateFormat'] . " H:i:s", strtotime($_GET['date']));
            $since = $since . "." . $milliseconds;
        }

        if(isset($_GET['limit']))
        {
            if($_GET['limit'] > 500)
            {
                throw new RestException(412,'Cannot return more than 500 rows');
            }
            else
            {
                $limit = (int)$_GET['limit'];
                $tsql = str_replace("100",$limit,$tsql,$replacements); //TODO: HACK: Multiple parameters in $tsql_params wasn't working. Fix this.
            }
        }

        $tsql_params = array(&$since);

        $rows = $this->run_query($tsql, $tsql_params);

        $output = $rows;

        return array('races' => $output);
    }

    protected function final_positions($heatNum = -1) {
        $output = array();
        $trackId = -1;

        if (!isset($_GET["race_id"]))
        {
            throw new RestException(412,'Please provide a race_id as a URL parameter');
        }

        $heatNum = $_GET["race_id"];

        if(!is_numeric($heatNum) && !empty($heatNum)) throw new RestException(412,'race_id ' . ($heatNum) .  ' is not a valid number');


        $raceSummary = $this->raceSummary($heatNum);
        if ($raceSummary["id"] == null || $raceSummary["finish_time"] == null)
        {
            throw new RestException(412, 'This race never finished.');
        }
        $output["race_id"] = $raceSummary["id"];
        $output["finish_time"] = $raceSummary["finish_time"];

        $tsql = "EXEC GetScoreboard " . $trackId . "," . $heatNum;
        $scoreboard = $this->run_query($tsql, array());

        $positions = array();
        foreach($scoreboard as $currentRacer)
        {
            $currentRacerInfo = array();
            $currentRacerInfo["position"] = $currentRacer["position"];
            $currentRacerInfo["racer_id"] = $currentRacer["racer_id"];
            $currentRacerInfo["nickname"] = $currentRacer["nickname"];
            $currentRacerInfo["first_name"] = $currentRacer["first_name"];
            $currentRacerInfo["last_name"] = $currentRacer["last_name"];
            $currentRacerInfo["rpm"] = $currentRacer["rpm"];
            //TODO: Ask Wes - are more details desired, like racer names?
            $positions[] = $currentRacerInfo;

        }
        $output["final_positions"] = $positions;

        return array("race" => $output);

    }

    /**
     * Get the fastest lap times. Defaults to fastest of day on most recently run speedlevel/track
     * @protected
     * @param array $options Optional, date range, day, week, month, year, speed level, track id, number to return
     * @return array
     */
    protected function fastest() {

        /*
        /results?range=day    " fastest of day
        /results?range=week   " fastest of week
        /results?range=month  " fastest of month
				/results?range=year   " fastest of year

        " Date range.
        /results?start=2012-01-01&end=2012-01-01

        " Tracks.
        /results?track=1

        " Speed Level.
        /results?speed_level=1

        " Limit results returned.
        /results?limit=5

        " Exclude employees
        /results?exclude_employees=1
        */

        $tsql_params = array();
        $tsql_range = '';
        $tsql_track = '';
        $tsql_weight= '';
        $tsql_gender= '';
        $tsql_speed_level = '';
        $tsql_exclude_employees = isset($_GET['exclude_employees']) && $_GET['exclude_employees'] == 1 ? true : false;
        $tsql_birthdate = '';

        if(isset($_GET['limit']) && is_numeric($_GET['limit'])) {
            if($_GET['limit'] > 100) throw new RestException(412,'Cannot return more than 100 rows');
            //$tsql_params[] = (int)$_GET['limit'];
            $limit = (int)$_GET['limit'];
        } else {
            //$tsql_params[] = 50;
            $limit = 50;
        }

        if(isset($_GET['range'])) {
            switch($_GET['range']) {
                case 'day':
                    $start = date($GLOBALS['dateFormat']) . ' 12:00:00 AM';
                    break;
                case 'week':
                    $start = date($GLOBALS['dateFormat'], strtotime('last Sunday')) . ' 12:00:00 AM';
                    break;
                case 'month':
                    $start = date($GLOBALS['dateFormat'], strtotime('first day of this month')) . ' 12:00:00 AM';
                    break;
								case 'year':
                    $start = date($GLOBALS['dateFormat'], strtotime('first day of january')) . ' 12:00:00 AM';
                    break;
                default:
                    throw new RestException(412,'Invalid range given');
            }

            $end = date($GLOBALS['dateFormat']) . ' 11:59:59 PM';
            $tsql_range = 'AND rd.TimeStamp BETWEEN ? AND ?';
            $tsql_params[] = &$start;
            $tsql_params[] = &$end;
        } elseif(isset($_GET['start']) && isset($_GET['end'])) {
            $start = date($GLOBALS['dateFormat'], strtotime($_GET['start'])) . ' 12:00:00 AM';
            $end = date($GLOBALS['dateFormat'], strtotime($_GET['end'])) . ' 11:59:59 PM';
            $tsql_range = 'AND rd.TimeStamp BETWEEN ? AND ?';
            $tsql_params[] = &$start;
            $tsql_params[] = &$end;
        }

        if(isset($_GET['track'])) {
            if(!is_numeric($_GET['track'])) throw new RestException(412,'Invalid track given');
            $tsql_track = 'AND hm.TrackNo = ?';
            $tsql_params[] = &$_GET['track'];
        }

        if(isset($_GET['gender'])) {
            $genders = array('m' => 1, 'f' => 2);
            if(!in_array(strtolower($_GET['gender']), array('m', 'f'))) throw new RestException(412,'Invalid gender given');
            $tsql_gender = 'AND c.Gender = ?';
            $tsql_params[] = &$genders[strtolower($_GET['gender'])];
        }

        if(isset($_GET['weight'])) {
            $weights = array('light' => 4, 'medium' => 5, 'heavy' => 10, 'sumo' => 11);
            if(!in_array($weights[$_GET['weight']], array(4,5,10,11))) throw new RestException(412,'Invalid weight given');
            $tsql_weight = 'AND c.Status3 = ?';
            $tsql_params[] = &$weights[$_GET['weight']];
        }

        if(isset($_GET['speed_level'])) {
            if(!is_numeric($_GET['speed_level'])) throw new RestException(412,'Invalid speed level given');
            $tsql_speed_level = 'AND hm.SpeedLevel = ?';
            $tsql_params[] = &$_GET['speed_level'];
        }

        if($tsql_exclude_employees) {
            $tsql_exclude_employees = 'AND c.IsEmployee = ?';
            $tsql_params[] = false;
        } else {
            $tsql_exclude_employees = '';
        }

        if(isset($_GET['start_birthdate']) && isset($_GET['end_birthdate'])) {
            $start_birthdate = date($GLOBALS['dateFormat'], strtotime($_GET['start_birthdate'])) . ' 12:00:00 AM';
            $end_birthdate = date($GLOBALS['dateFormat'], strtotime($_GET['end_birthdate'])) . ' 11:59:59 PM';
            $tsql_birthdate = 'AND c.BirthDate BETWEEN ? AND ?';
            $tsql_params[] = &$start_birthdate;
            $tsql_params[] = &$end_birthdate;
        }

        $tsql = <<<EOD
		SELECT DISTINCT TOP ($limit) MAX(rd.CustID) AS CustID, MAX(c.FName) AS FirstName, MAX(c.LName) AS LastName, MAX(c.RacerName) AS RacerName, MAX(c.RPM) AS rpm, MIN(rd.LTime) AS LTime, MAX(rd.TimeStamp) AS TimeStamp, MAX(rd.LapNum) AS LapNum, MAX(hm.SpeedLevel) AS SpeedLevel, MAX(hm.TrackNo) AS TrackNo, MIN(t.Description) AS TrackName
		FROM         RacingData AS rd LEFT OUTER JOIN
							  Customers AS c ON c.CustID = rd.CustID LEFT OUTER JOIN Tracks t ON TrackNo = t.TrackNo LEFT OUTER JOIN
							  HeatMain AS hm ON hm.HeatNo = rd.HeatNo 
		WHERE  (rd.LTime <> 0) AND (rd.IsBadTime <> 'true') $tsql_range $tsql_track $tsql_gender $tsql_weight $tsql_speed_level $tsql_exclude_employees $tsql_birthdate
		GROUP BY c.RacerName
		ORDER BY LTime
EOD;

        $rows = $this->run_query($tsql, $tsql_params);

        $output = array();

        foreach($rows as $row) {
            $output[] = array('racer_id' => $row['CustID'],
                'nickname' => $row['RacerName'],
                'first_name' => $row['FirstName'],
                'rpm' => $row['rpm'],
                'last_name' => $row['LastName'],
                'lap_time' => round($row['LTime'] / 1000, 3),
                'lap_number' => $row['LapNum'],
                'speed_level' => $row['SpeedLevel'],
                'track_id' => $row['TrackNo'],
                'track_name' => $row['TrackName'],
                'timestamp' => date($GLOBALS['dateFormat'] . ' H:i:s', strtotime($row['TimeStamp'])),
            );

        }

        return array('fastest' => $output);
    }

    protected function scoreboard($trackId = -1, $heatNum = -1) {
        $race = array();

        if(!is_numeric($trackId) && !empty($trackId)) throw new RestException(412,'track_id is not a valid number');
        if(!is_numeric($heatNum) && !empty($heatNum)) throw new RestException(412,'heat_id ' . ($heatNum) .  ' is not a valid number');

        // Searching by heat
        if(empty($trackId)) {
            $trackId = -1;
            $race = $this->raceSummary($heatNum);
        }

        // Searching by track
        if(empty($heatNum)) {
            $heatNum = -1;
            $race = $this->raceSummary($this->current($trackId));
        }

        $output = array();
        $tsql = "EXEC GetScoreboard " . $trackId . "," . $heatNum;
        $scoreboard = $this->run_query($tsql, array());
        return array('race' => $race, 'scoreboard' => $scoreboard);

    }

    protected function raceSummary($heatId) {
        $tsql = "SELECT hm.*, ht.HeatTypeName, sl.Description AS sl_Description, t.Description AS t_Description FROM HeatMain hm LEFT JOIN HeatTypes ht ON ht.HeatTypeNo = hm.HeatTypeNo LEFT JOIN Tracks t ON t.TrackNo = hm.TrackNo LEFT JOIN SpeedLevel sl ON hm.SpeedLevel = sl.SpeedLevel WHERE HeatNo = ?";
        $heat = $this->run_query($tsql, array(&$heatId));

        $win_by  = array(0 => 'laptime', 1 => 'position');
        $race_by = array(0 => 'minutes', 1 => 'laps');

        foreach($heat as $row) {

            if($row['HeatStatus'] == 1) {
                if($row['RaceBy'] == 0) {
                    $tsql = "select top 1 datediff(ms, timestamp, current_timestamp) as time from racingdata where heatno = ? order by timestamp";
                    $raceTimeInSeconds = $this->run_query($tsql, array(&$heatId));
                    $raceTimeInSeconds = $raceTimeInSeconds[0]['time'] / 1000;
                    //TODO: Evaluate this functionality. At the moment the details are being handled by the user of the API.
                } else {
                    $tsql = "select top 1 datediff(ms, timestamp, current_timestamp) as time from racingdata where heatno = ? order by timestamp";
                    $raceTimeInSeconds = $this->run_query($tsql, array(&$heatId));
                    $raceTimeInSeconds = $raceTimeInSeconds[0]['time'] / 1000;
                }

            } else {
                $raceTimeInSeconds = null;
            }

            $output = array('id' => $row['HeatNo'],
                'track_id' => $row['TrackNo'],
                'track' => $row['t_Description'],
                'starts_at' => $row['ScheduledTime'],
                'finish_time' => $row['Finish'],
                'heat_type_id' => $row['HeatTypeNo'],
                'heat_status_id' => $row['HeatStatus'],
                'speed_level_id' => $row['SpeedLevel'],
                'speed_level' => $row['sl_Description'],
                'win_by' => $win_by[$row['WinBy']],
                'race_by' => $race_by[$row['RaceBy']],
                'duration' => $row['RaceBy'] == 0 ? $row['LapsOrMinutes']/60 : $row['LapsOrMinutes'],
                'race_name' => $row['HeatTypeName'],
                'race_time_in_seconds' => $raceTimeInSeconds
            );
        }
        return @$output;
    }

    /**
     * Get the racers, laps and other details of a heat
     * @protected
     * @param integer $heatId Optional, heat to return, defaults to currently running heat
     * @return array
     */
    protected function race($heatId) {
        if(!is_numeric($heatId) && !in_array($heatId, array('current', 'next'))) throw new RestException(412,'Heat ID is not a number, "next" or "current"');
        $output = array();

        //$tsql = 'GetNextHeatInfo';
        $track_id = (isset($_GET['track']) && is_numeric($_GET['track'])) ? (int)$_GET['track'] : 1;
        if (is_numeric($heatId))
        {
            $tsql = 'GetHeatInfoByHeatNo' . ' ' . $heatId;
        }
        else
        {
            $tsql = 'GetNextHeatInfo' . ' ' . $track_id;
        }
        //$tsql_params = array(&$track_id);
        $rowsRace = $this->run_query($tsql);

        $output['race'] = $rowsRace[0];
				$output['race']['race_number'] = substr($output['race']['id'], -2); // Race Number is the last two digits of the ID

        //$tsql = 'GetNextHeatRacersInfo';
        $tsql_params = array(&$heatId);
        $tsql = 'Select hd.CustID id, hd.LineUpPosition start_position, CASE autono WHEN -1 then hd.historyautono ELSE autono END AS kart_number, hd.RPM rpm, case when c.TotalRaces > 1 then 1 else 0 end is_first_time, hd.FinishPosition finish_position, c.RacerName nickname, c.FName first_name, c.LName last_name From HeatMain hm inner join HeatTypes ht on hm.HeatTypeNo = ht.HeatTypeNo inner join SpeedLevel sl on hm.SpeedLevel = sl.SpeedLevel inner join Tracks t on hm.trackno = t.TrackNo inner join HeatDetails hd on hm.heatno = hd.heatno inner join Customers c on hd.CustID = c.CustID Where hd.HeatNo = ? order by hd.LineUpPosition';
        $rowsRacers = $this->run_query($tsql, $tsql_params);
        $output['race']['racers'] = $rowsRacers;

				foreach($output['race']['racers'] as $key => $racer) {
					$racerInfo = $this->run_query('GetRacerProfile '.(int)$racer['id'].', ' . (int)$heatId, array());
					$output['race']['racers'][$key]['total_customers'] = $racerInfo[0]['TotalCustomers'];
					$output['race']['racers'][$key]['ranking_by_rpm'] = $racerInfo[0]['RankingByRPM'];
					$output['race']['racers'][$key]['group_id'] = $racerInfo[0]['GroupID'];
					$output['race']['racers'][$key]['total_visits'] = $racerInfo[0]['TotalVisits'];
					$output['race']['racers'][$key]['total_races'] = $racerInfo[0]['TotalRaces'];
				}

        if (is_numeric($heatId)) //TODO: Document and explain the SQL 2005 hacks
        {
            $tsql = "SELECT * FROM RacingData WHERE HeatNo = " . $heatId . " AND IsBadTime = 0";
            $laps = $this->run_query($tsql);
            
						// Build mapping between customer id and the key in the array
						$racersToKeys = array();
						foreach($output['race']['racers'] as $key => $racer) {
							$racersToKeys[$racer['id']] = $key;
						}
						
						foreach($laps as $lap) {
                $currentLap = array(
                    'id' => $lap['ID'],
                    'kart_number' => $lap['AutoNo'],
                    'lap_time' => $lap['LTime']/1000,
                    'amb_time' => $lap['AMBTime']/1000,
                    'lap_number' => $lap['LapNum'],
                    'racer_id' => $lap['CustID']
                );
								
								$key = $racersToKeys[$currentLap['racer_id']];
								$output['race']['racers'][$key]['laps'][] = $currentLap;
								$output['race']['laps'][] = $currentLap;
            }

            if(isset($output['race']['laps'])) {
                $output = $output + $this->scoreboard(-1, (int)($heatId));
            }
        }

        return $output;
    }

    /**
     * Get # of passings from a heat
     * @protected
     * @param integer $heatId Optional, heat to return, defaults to currently running heat
     * @return array
     */
    protected function number_of_laps($heatId = null) {
        // If heatId == null, get current heat

        $tsql_params = array(&$heatId);

        $tsql = "SELECT COUNT(*) AS passes FROM RacingData WHERE HeatNo = ? AND IsBadTime = 0";
        $laps = $this->run_query($tsql, $tsql_params);

        $output = $laps[0]['passes'];

        return array('laps' => $output);
    }

    /**
     * Get the laps from a heat
     * @protected
     * @param integer $heatId Optional, heat to return, defaults to currently running heat
     * @param integer $lapId Optional, returns only laps after lap id.
     * @param integer $racerId Optional, returns only laps for this racer id.
     * @return array
     */
    protected function laps($heatId = null, $lapId = 0, $racerId = null) {
        // If heatId == null, get current heat

        $tsql_params = array(&$heatId, &$lapId);

        $racerId_tsql = '';
        if($racerId !== null) { // Limit by racerId
            $racerId_tsql = 'AND CustID = ?';
            $tsql_params[] = &$racerId;
        }
        $tsql = "SELECT * FROM RacingData WHERE HeatNo = ? AND IsBadTime = 0 AND ID > ? $racerId_tsql";
        $laps = $this->run_query($tsql, $tsql_params);

        $output = array();
        foreach($laps as $lap) {
            $output[] = array(
                'id' => $lap['ID'],
                'kartNo' => $lap['AutoNo'],
                'lapTime' => $lap['LTime']/1000,
                'lapNum' => $lap['LapNum'],
                'racerId' => $lap['CustID']
            );
        }

        return array('laps' => $output);
    }

    private function run_query($tsql, $params = array()) {
    $tsql_original = $tsql . ' ';
        // Connect
        try {
            $conn = new PDO( "sqlsrv:server=(local) ; Database=ClubSpeedV8", "", "");
            $conn->setAttribute( PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION );

/*            if ($tsql == "GetNextHeatInfo ?")
            {
                $tsql = "GetNextHeatInfo 1";
            }

            if ($tsql == "GetNextHeatRacersInfo ?")
            {
                $tsql = "GetNextHeatRacersInfo 1";
            }*/

            // Prepare statement
            $stmt = $conn->prepare($tsql);

            // Execute statement

            $stmt->execute($params);

            // Put in array
            $output = $stmt->fetchAll(PDO::FETCH_ASSOC);

        } catch(Exception $e) {
            die('Exception Message:'  . $e->getMessage()  . '<br/>(Line: '. $e->getLine() . ')' . '<br/>Passed query: ' . $tsql_original . '<br/>Parameters passed: ' . print_r($params,true));
        }

        return $output;
    }

}